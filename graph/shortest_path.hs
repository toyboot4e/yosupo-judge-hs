-- {{{ toy-lib: https://github.com/toyboot4e/toy-lib
{-# OPTIONS_GHC -Wno-unused-imports -Wno-unused-top-binds -Wno-orphans #-}
{- ORMOLU_DISABLE -}
{-# LANGUAGE BlockArguments, CPP, DefaultSignatures, DerivingVia, LambdaCase, MultiWayIf, NumDecimals, PatternSynonyms, QuantifiedConstraints, RecordWildCards, StandaloneDeriving, StrictData, TypeFamilies #-}
import Control.Applicative;import Control.DeepSeq;import Control.Exception (assert);import Control.Monad;import Control.Monad.Fix;import Control.Monad.IO.Class;import Control.Monad.Primitive;import Control.Monad.ST;import Control.Monad.State.Class;import Control.Monad.Trans (MonadTrans, lift);import Control.Monad.Trans.State.Strict (State, StateT, runState, evalState, execState, runStateT, evalStateT, execStateT);import Data.Bifunctor;import Data.Bits;import Data.Bool (bool);import Data.Char;import Data.Coerce;import Data.Either;import Data.Foldable;import Data.Function (on);import Data.Functor;import Data.Functor.Identity;import Data.IORef;import Data.List.Extra hiding (nubOn);import Data.Maybe;import Data.Ord;import Data.Primitive.MutVar;import Data.Proxy;import Data.STRef;import Data.Semigroup;import Data.Word;import Debug.Trace;import GHC.Exts;import GHC.Float (int2Float);import GHC.Ix (unsafeIndex);import GHC.Stack (HasCallStack);import System.Exit (exitSuccess);import System.IO;import System.Random;import System.Random.Stateful;import Text.Printf;import qualified Data.Ratio as Ratio;import Data.Array.IArray;import Data.Array.IO;import Data.Array.MArray;import Data.Array.ST;import Data.Array.Unboxed (UArray);import Data.Array.Unsafe;import qualified Data.Array as A;import qualified Data.ByteString.Builder as BSB;import qualified Data.ByteString.Char8 as BS;import qualified Data.ByteString.Unsafe as BSU;import Control.Monad.Extra hiding (loop);import Data.IORef.Extra;import Data.List.Extra hiding (merge);import Data.Tuple.Extra hiding (first, second);import Numeric.Extra;import Data.Bool.HT;import qualified Data.Ix.Enum as HT;import qualified Data.List.HT as HT;import qualified Data.Vector.Fusion.Bundle as FB;import qualified Data.Vector.Generic as G;import qualified Data.Vector.Generic.Mutable as GM;import qualified Data.Vector.Primitive as P;import qualified Data.Vector.Unboxed as U;import qualified Data.Vector.Unboxed.Base as U;import qualified Data.Vector.Unboxed.Mutable as UM;import qualified Data.Vector as V;import qualified Data.Vector.Mutable as VM;import qualified Data.Vector.Fusion.Bundle.Monadic as MB;import qualified Data.Vector.Fusion.Bundle.Size as MB;import qualified Data.Vector.Fusion.Stream.Monadic as MS;import qualified Data.Vector.Algorithms.Merge as VAM;import qualified Data.Vector.Algorithms.Intro as VAI;import qualified Data.Vector.Algorithms.Search as VAS;import Data.Graph (Vertex);import qualified Data.IntMap.Strict as IM;import qualified Data.Map.Strict as M;import qualified Data.IntSet as IS;import qualified Data.Set as S;import qualified Data.Sequence as Seq;import qualified Data.Heap as H;import qualified Data.HashMap.Strict as HM;import qualified Data.HashSet as HS;import qualified Test.QuickCheck as QC
{-# RULES "Force inline VAI.sort" VAI.sort = VAI.sortBy compare #-}
#ifdef DEBUG
dbg :: Show a => a -> () ; dbg !x = let !_ = traceShow x () in () ; dbgAssert :: Bool -> String -> () ; dbgAssert False !s = error $ "assertion failed!: " ++ s ; dbgAssert True _ = () ; dbgS :: String -> () ; dbgS !s = let !_ = trace s () in () ; dbgId :: Show a => a -> a ; dbgId !x = let !_ = traceShow x () in x ; note :: (Show s, Show a) => s -> a -> a ; note !s !x = let !_ = trace (show s ++ ": " ++ show x) () in x ;
#else
dbg :: Show a => a -> () ; dbg _ = () ; dbgAssert :: Bool -> a -> a ; dbgAssert = flip const ; dbgS :: String -> () ; dbgS _ = () ; dbgId :: Show a => a -> a ; dbgId = id ; note :: (Show s, Show a) => s -> a -> a ; note _ !x = x ;
#endif
type SparseUnionFind = IM.IntMap Int;newSUF :: SparseUnionFind;newSUF = IM.empty;memberSUF :: Int -> SparseUnionFind -> Bool;memberSUF = IM.member;insertSUF :: Int -> SparseUnionFind -> SparseUnionFind;insertSUF !x !uf = IM.insert x (-1) uf;fromListSUF :: [(Int, Int)] -> SparseUnionFind;fromListSUF = foldl' (\ uf (!i, !j) -> unifySUF i j uf) newSUF;fromVecSUF :: U.Vector (Int, Int) -> SparseUnionFind;fromVecSUF = U.foldl' (\ uf (!i, !j) -> unifySUF i j uf) newSUF;rootSUF :: (HasCallStack) => Int -> SparseUnionFind -> (Int, Int);rootSUF !i !uf | IM.notMember i uf = (i, 1) | j < 0 = (i, -j) | otherwise = rootSUF j uf where { j = uf IM.! i};sameSUF :: (HasCallStack) => Int -> Int -> SparseUnionFind -> Bool;sameSUF !i !j !uf = fst (rootSUF i uf) == fst (rootSUF j uf);unifySUF :: (HasCallStack) => Int -> Int -> SparseUnionFind -> SparseUnionFind;unifySUF !i !j !uf | a == b = uf | r >= s = IM.insert a (negate $! r + s) $ IM.insert b a uf | otherwise = IM.insert b (negate $! r + s) $ IM.insert a b uf where { (!a, !r) = rootSUF i uf; (!b, !s) = rootSUF j uf};newtype MUnionFind s = MUnionFind (UM.MVector s MUFNode);type IOUnionFind = MUnionFind RealWorld;type STUnionFind s = MUnionFind s;data MUFNode = MUFChild {-# UNPACK #-} !Int | MUFRoot {-# UNPACK #-} !Int deriving (Eq, Show);instance U.IsoUnbox MUFNode (Bool, Int) where { {-# INLINE toURepr #-}; toURepr (MUFChild !x) = (True, x); toURepr (MUFRoot !x) = (False, x); {-# INLINE fromURepr #-}; fromURepr (True, !x) = MUFChild x; fromURepr (False, !x) = MUFRoot x};newtype instance  U.MVector s MUFNode = MV_MUFNode (UM.MVector s (Bool, Int));newtype instance  U.Vector MUFNode = V_MUFNode (U.Vector (Bool, Int));deriving via (MUFNode `U.As` (Bool, Int)) instance GM.MVector UM.MVector MUFNode;deriving via (MUFNode `U.As` (Bool, Int)) instance G.Vector U.Vector MUFNode;instance U.Unbox MUFNode;{-# INLINE newMUF #-};newMUF :: (PrimMonad m) => Int -> m (MUnionFind (PrimState m));newMUF !n = MUnionFind <$> UM.replicate n (MUFRoot 1);{-# INLINE rootMUF #-};rootMUF :: (HasCallStack, PrimMonad m) => MUnionFind (PrimState m) -> Int -> m Int;rootMUF uf@(MUnionFind !vec) i = do { !node <- UM.unsafeRead vec i; case node of { MUFRoot _ -> return i; MUFChild p -> do { !r <- rootMUF uf p; UM.unsafeWrite vec i (MUFChild r); return r}}};{-# INLINE groupsMUF #-};groupsMUF :: (HasCallStack, PrimMonad m) => MUnionFind (PrimState m) -> m IS.IntSet;groupsMUF uf@(MUnionFind !vec) = foldM step IS.empty [0 .. pred (GM.length vec)] where { step !is !i = do { !root <- rootMUF uf i; return $ IS.insert root is}};{-# INLINE sameMUF #-};sameMUF :: (HasCallStack, PrimMonad m) => MUnionFind (PrimState m) -> Int -> Int -> m Bool;sameMUF !uf !x !y = liftM2 (==) (rootMUF uf x) (rootMUF uf y);_unwrapMUFRoot :: MUFNode -> Int;_unwrapMUFRoot (MUFRoot !s) = s; _unwrapMUFRoot (MUFChild !_) = error "tried to unwrap child as UF root";{-# INLINE unifyMUF #-};unifyMUF :: (HasCallStack, PrimMonad m) => MUnionFind (PrimState m) -> Int -> Int -> m Bool;unifyMUF uf@(MUnionFind !vec) !x !y = do { !px <- rootMUF uf x; !py <- rootMUF uf y; when (px /= py) $ do { !sx <- _unwrapMUFRoot <$> UM.unsafeRead vec px; !sy <- _unwrapMUFRoot <$> UM.unsafeRead vec py; let { (!par, !chld) = if sx < sy then (px, py) else (py, px)}; UM.unsafeWrite vec chld (MUFChild par); UM.unsafeWrite vec par (MUFRoot $! sx + sy)}; return $ px /= py};{-# INLINE unifyMUF_ #-};unifyMUF_ :: (HasCallStack, PrimMonad m) => MUnionFind (PrimState m) -> Int -> Int -> m ();unifyMUF_ uf x y = void $ unifyMUF uf x y;{-# INLINE sizeMUF #-};sizeMUF :: (HasCallStack, PrimMonad m) => MUnionFind (PrimState m) -> Int -> m Int;sizeMUF uf@(MUnionFind !vec) !x = do { !px <- rootMUF uf x; _unwrapMUFRoot <$> UM.unsafeRead vec px};{-# INLINE clearMUF #-};clearMUF :: (PrimMonad m) => MUnionFind (PrimState m) -> m ();clearMUF (MUnionFind !vec) = do { UM.set vec (MUFRoot 1)};data PUnionFind s = DUnionFind{nodesPUF :: UM.MVector s MUFNode, potencialPUF :: UM.MVector s Int};newPUF :: (PrimMonad m) => Int -> m (PUnionFind (PrimState m));newPUF n = DUnionFind <$> UM.replicate n (MUFRoot 1) <*> UM.replicate n (0 :: Int);rootPUF :: (PrimMonad m) => PUnionFind (PrimState m) -> Int -> m Int;rootPUF uf = inner where { inner v = UM.read (nodesPUF uf) v >>= \case { MUFRoot _ -> return v; MUFChild p -> do { !r <- inner p; when (p /= r) $ do { !pp <- UM.read (potencialPUF uf) p; UM.write (nodesPUF uf) v (MUFChild r); UM.modify (potencialPUF uf) (pp +) v}; return r}}};unifyPUF :: (PrimMonad m) => PUnionFind (PrimState m) -> Int -> Int -> Int -> m Bool;unifyPUF !uf !v1 !v2 !dp = do { !r1 <- rootPUF uf v1; !r2 <- rootPUF uf v2; if r1 == r2 then return False else do { !size1 <- UM.read (potencialPUF uf) v1; !size2 <- UM.read (potencialPUF uf) v2; if size1 < size2 then unifyPUF uf v2 v1 (-dp) else do { !sz1 <- _unwrapMUFRoot <$> UM.read (nodesPUF uf) r1; !sz2 <- _unwrapMUFRoot <$> UM.read (nodesPUF uf) r2; UM.write (nodesPUF uf) r1 (MUFRoot (sz1 + sz2)); !p1 <- UM.read (potencialPUF uf) v1; !p2 <- UM.read (potencialPUF uf) v2; let { !pr2 = p1 - p2 - dp}; UM.write (nodesPUF uf) r2 (MUFChild r1); UM.write (potencialPUF uf) r2 pr2; return True}}};sizePUF :: (PrimMonad m) => PUnionFind (PrimState m) -> Int -> m Int;sizePUF !uf !v = fmap _unwrapMUFRoot . UM.read (nodesPUF uf) =<< rootPUF uf v;samePUF :: (PrimMonad m) => PUnionFind (PrimState m) -> Int -> Int -> m Bool;samePUF !uf !v1 !v2 = (==) <$> rootPUF uf v1 <*> rootPUF uf v2;canUnifyPUF :: (PrimMonad m) => PUnionFind (PrimState m) -> Int -> Int -> Int -> m Bool;canUnifyPUF !uf !v1 !v2 !d = do { !r1 <- rootPUF uf v1; !r2 <- rootPUF uf v2; !p1 <- UM.read (potencialPUF uf) v1; !p2 <- UM.read (potencialPUF uf) v2; return $ r1 /= r2 || p1 - p2 == d};potPUF :: (PrimMonad m) => PUnionFind (PrimState m) -> Int -> m Int;potPUF !uf !v1 = do { void $ rootPUF uf v1; UM.read (potencialPUF uf) v1};diffPUF :: (PrimMonad m) => PUnionFind (PrimState m) -> Int -> Int -> m Int;diffPUF !uf !v1 !v2 = (-) <$> potPUF uf v1 <*> potPUF uf v2;clearPUF :: (PrimMonad m) => PUnionFind (PrimState m) -> m ();clearPUF !uf = do { UM.set (potencialPUF uf) (0 :: Int); UM.set (nodesPUF uf) (MUFRoot 1)};data SegmentTree v s a = SegmentTree (a -> a -> a) (v s a);{-# INLINE newSTreeG #-};newSTreeG :: (GM.MVector v a, PrimMonad m) => (a -> a -> a) -> Int -> a -> m (SegmentTree v (PrimState m) a);newSTreeG !f !nLeaves !zero = SegmentTree f <$> GM.replicate nVerts zero where { !nVerts = until (>= 2 * nLeaves) (* 2) 2};{-# INLINE newSTreeV #-};newSTreeV :: (PrimMonad m) => (a -> a -> a) -> Int -> a -> m (SegmentTree VM.MVector (PrimState m) a);newSTreeV = newSTreeG;{-# INLINE newSTreeU #-};newSTreeU :: (U.Unbox a, PrimMonad m) => (a -> a -> a) -> Int -> a -> m (SegmentTree UM.MVector (PrimState m) a);newSTreeU = newSTreeG;resetSTree :: (GM.MVector v a, PrimMonad m) => SegmentTree v (PrimState m) a -> a -> m ();resetSTree (SegmentTree !_ !vec) !zero = GM.set vec zero;{-# INLINE insertSTree #-};insertSTree :: (GM.MVector v a, PrimMonad m) => SegmentTree v (PrimState m) a -> Int -> a -> m ();insertSTree tree@(SegmentTree !_ !vec) !i !value = _updateElement tree i' value where { !offset = GM.length vec `div` 2 - 1; !i' = i + offset};{-# INLINE modifySTree #-};modifySTree :: (GM.MVector v a, PrimMonad m) => SegmentTree v (PrimState m) a -> (a -> a) -> Int -> m ();modifySTree tree@(SegmentTree !_ !vec) !f !i = do { !v <- f <$> GM.unsafeRead vec i'; _updateElement tree i' v} where { !offset = GM.length vec `div` 2 - 1; !i' = i + offset};_updateElement :: (HasCallStack, GM.MVector v a, PrimMonad m) => SegmentTree v (PrimState m) a -> Int -> a -> m ();_updateElement (SegmentTree !_ !vec) 0 !value = do { GM.unsafeWrite vec 0 value}; _updateElement tree@(SegmentTree !f !vec) !i !value = do { GM.unsafeWrite vec i value; case (i - 1) `div` 2 of { (-1) -> return (); !iParent -> do { !c1 <- GM.unsafeRead vec $! iParent * 2 + 1; !c2 <- GM.unsafeRead vec $! iParent * 2 + 2; _updateElement tree iParent $! f c1 c2}}};{-# INLINE querySTree #-};querySTree :: forall v a m . (HasCallStack, GM.MVector v a, PrimMonad m) => SegmentTree v (PrimState m) a -> Int -> Int -> m (Maybe a);querySTree (SegmentTree !f !vec) !lo !hi | lo > hi = return Nothing | lo < 0 || hi >= (GM.length vec `div` 2) = return Nothing | otherwise = inner 0 0 initialHi where { !initialHi = GM.length vec `div` 2 - 1; inner :: Int -> Int -> Int -> m (Maybe a); inner !i !l !h | lo <= l && h <= hi = Just <$> GM.unsafeRead vec i | h < lo || hi < l = return Nothing | otherwise = do { let { !d = (h - l) `div` 2}; !ansL <- inner (2 * i + 1) l (l + d); !ansH <- inner (2 * i + 2) (l + d + 1) h; pure . Just $ case (ansL, ansH) of { (Just !a, Just !b) -> f a b; (Just !a, _) -> a; (_, Just !b) -> b; (_, _) -> error $ "query error (segment tree): " ++ show (i, (l, h), (lo, hi))}}};{-# INLINE constructNM #-};constructNM :: forall a m . (PrimMonad m, U.Unbox a) => Int -> (U.Vector a -> m a) -> m (U.Vector a);constructNM !n f = do { v <- GM.new n; v' <- G.unsafeFreeze v; fill v' 0} where { fill :: U.Vector a -> Int -> m (U.Vector a); fill !v i | i < n = do { x <- f (G.unsafeTake i v); G.elemseq v x $ do { v' <- G.unsafeThaw v; GM.unsafeWrite v' i x; v'' <- G.unsafeFreeze v'; fill v'' (i + 1)}}; fill v _ = return v};{-# INLINE constructrNM #-};constructrNM :: forall a m . (PrimMonad m, U.Unbox a) => Int -> (U.Vector a -> m a) -> m (U.Vector a);constructrNM !n f = do { v <- n `seq` GM.new n; v' <- G.unsafeFreeze v; fill v' 0} where { fill :: U.Vector a -> Int -> m (U.Vector a); fill !v i | i < n = do { x <- f (G.unsafeSlice (n - i) i v); G.elemseq v x $ do { v' <- G.unsafeThaw v; GM.unsafeWrite v' (n - i - 1) x; v'' <- G.unsafeFreeze v'; fill v'' (i + 1)}}; fill v _ = return v};{-# INLINE csum1D #-};csum1D :: (Num a, U.Unbox a) => U.Vector a -> U.Vector a;csum1D = U.scanl' (+) 0;{-# INLINE (+!) #-};(+!) :: (Num a, U.Unbox a) => U.Vector a -> (Int, Int) -> a;(+!) csum (!l, !r) = csum U.! succ r - csum U.! l;class SemigroupAction s a where { sact :: s -> a -> a};class (SemigroupAction m a, Monoid m) => MonoidAction m a where { mact :: m -> a -> a; mact = sact};instance SemigroupAction (Product Int) Int where { sact (Product !x1) !x2 = x1 * x2};newtype Permutation = Permutation (U.Vector Int) deriving (Show, Eq);instance Semigroup Permutation where { (Permutation vec1) <> (Permutation vec2) = Permutation $! U.map (vec1 U.!) vec2 where { !_ = dbgAssert (G.length vec1 == G.length vec2)}};instance SemigroupAction Permutation Int where { sact (Permutation !vec) !i = vec U.! i};data LazySegmentTree v a op s = LazySegmentTree !(v s a) !(UM.MVector s op) !Int;newLazySTree :: forall v a op m . (GM.MVector v a, Monoid a, MonoidAction op a, U.Unbox op, PrimMonad m) => Int -> m (LazySegmentTree v a op (PrimState m));newLazySTree !n = do { !as <- GM.replicate n2 mempty; !ops <- UM.replicate n2 mempty; return $ LazySegmentTree as ops h} where { (!h, !n2) = until ((>= 2 * n) . snd) (bimap succ (* 2)) (0 :: Int, 1 :: Int)};newLazySTreeV :: forall a op m . (Monoid a, MonoidAction op a, U.Unbox op, PrimMonad m) => Int -> m (LazySegmentTree VM.MVector a op (PrimState m));newLazySTreeV = newLazySTree;newLazySTreeU :: forall a op m . (U.Unbox a, Monoid a, MonoidAction op a, U.Unbox op, PrimMonad m) => Int -> m (LazySegmentTree UM.MVector a op (PrimState m));newLazySTreeU = newLazySTree;generateLazySTreeG :: forall v a op m . (HasCallStack, GM.MVector v a, Monoid a, MonoidAction op a, U.Unbox op, PrimMonad m) => Int -> (Int -> a) -> m (LazySegmentTree v a op (PrimState m));generateLazySTreeG !n !f = do { !as <- GM.unsafeNew n2; forM_ [1 .. nLeaves] $ \ i -> do { if i <= n then GM.write as (nLeaves + i - 1) $! f (pred i) else GM.write as (nLeaves + i - 1) mempty}; forM_ [nLeaves - 1, nLeaves - 2 .. 1] $ \ i -> do { !l <- GM.read as (childL i); !r <- GM.read as (childR i); GM.write as i (l <> r)}; !ops <- UM.replicate n2 mempty; return $ LazySegmentTree as ops h} where { (!h, !n2) = until ((>= 2 * n) . snd) (bimap succ (* 2)) (0 :: Int, 1 :: Int); !nLeaves = n2 `div` 2; childL !vertex = shiftL vertex 1; childR !vertex = shiftL vertex 1 .|. 1};generateLazySTreeV :: forall a op m . (HasCallStack, Monoid a, MonoidAction op a, U.Unbox op, PrimMonad m) => Int -> (Int -> a) -> m (LazySegmentTree VM.MVector a op (PrimState m));generateLazySTreeV = generateLazySTreeG;generateLazySTreeU :: forall a op m . (HasCallStack, U.Unbox a, Monoid a, MonoidAction op a, U.Unbox op, PrimMonad m) => Int -> (Int -> a) -> m (LazySegmentTree UM.MVector a op (PrimState m));generateLazySTreeU = generateLazySTreeG;updateLazySTree :: forall v a op m . (GM.MVector v a, Monoid a, MonoidAction op a, Eq op, U.Unbox op, PrimMonad m) => LazySegmentTree v a op (PrimState m) -> Int -> Int -> op -> m ();updateLazySTree stree@(LazySegmentTree !_ !ops !_) !iLLeaf !iRLeaf !op = do { let { !_ = dbgAssert (inRange (0, nLeaves - 1) iLLeaf && inRange (0, nLeaves - 1) iRLeaf) $ "updateLazySTree: wrong range " ++ show (iLLeaf, iRLeaf)}; _propOpMonoidsToLeaf stree iLLeaf; _propOpMonoidsToLeaf stree iRLeaf; let { !lVertex = iLLeaf + nLeaves; !rVertex = iRLeaf + nLeaves}; glitchLoopUpdate lVertex rVertex; _evalToRoot stree iLLeaf; _evalToRoot stree iRLeaf; return ()} where { !nLeaves = UM.length ops `div` 2; isLeftChild = not . (`testBit` 0); isRightChild = (`testBit` 0); glitchLoopUpdate :: Int -> Int -> m (); glitchLoopUpdate !l !r | l > r = return () | otherwise = do { !l' <- if isRightChild l then do { UM.modify ops (<> op) l; return $ succ l} else return l; !r' <- if isLeftChild r then do { UM.modify ops (<> op) r; return $ pred r} else return r; glitchLoopUpdate (shiftR l' 1) (shiftR r' 1)}};queryLazySTree :: forall v a m op . (HasCallStack, GM.MVector v a, Monoid a, MonoidAction op a, Eq op, U.Unbox op, PrimMonad m) => LazySegmentTree v a op (PrimState m) -> Int -> Int -> m a;queryLazySTree stree@(LazySegmentTree !as !ops !_) !iLLeaf !iRLeaf = do { let { !_ = dbgAssert (inRange (0, nLeaves - 1) iLLeaf && inRange (0, nLeaves - 1) iRLeaf) $ "queryLazySTree: wrong range " ++ show (iLLeaf, iRLeaf)}; _propOpMonoidsToLeaf stree iLLeaf; _propOpMonoidsToLeaf stree iRLeaf; let { !lVertex = iLLeaf + nLeaves; !rVertex = iRLeaf + nLeaves}; glitchLoopQuery lVertex rVertex mempty mempty} where { !nLeaves = GM.length as `div` 2; isLeftChild = not . (`testBit` 0); isRightChild = (`testBit` 0); glitchLoopQuery :: Int -> Int -> a -> a -> m a; glitchLoopQuery !l !r !lAcc !rAcc | l > r = return $! lAcc <> rAcc | otherwise = do { (!l', !lAcc') <- if isRightChild l then do { !la' <- mact <$!> UM.read ops l <*> GM.read as l; return (succ l, lAcc <> la')} else return (l, lAcc); (!r', !rAcc') <- if isLeftChild r then do { !ra' <- mact <$!> UM.read ops r <*> GM.read as r; return (pred r, ra' <> rAcc)} else return (r, rAcc); glitchLoopQuery (shiftR l' 1) (shiftR r' 1) lAcc' rAcc'}};_propOpMonoidsToLeaf :: (HasCallStack, GM.MVector v a, MonoidAction op a, Eq op, U.Unbox op, PrimMonad m) => LazySegmentTree v a op (PrimState m) -> Int -> m ();_propOpMonoidsToLeaf (LazySegmentTree !as !ops !height) !iLeaf = do { let { !leafVertex = iLeaf + nVerts `div` 2}; forM_ [height - 1, height - 2 .. 1] $ \ iParent -> do { let { !vertex = nthParent leafVertex iParent}; !op <- UM.read ops vertex; when (op /= mempty) $ do { UM.modify ops (<> op) $! childL vertex; UM.modify ops (<> op) $! childR vertex; GM.modify as (mact op) vertex; UM.write ops vertex mempty}}} where { !nVerts = GM.length as; nthParent !leafVertex !nth = shiftR leafVertex nth; childL !vertex = shiftL vertex 1; childR !vertex = shiftL vertex 1 .|. 1};_evalToRoot :: (HasCallStack, GM.MVector v a, Monoid a, MonoidAction op a, U.Unbox op, PrimMonad m) => LazySegmentTree v a op (PrimState m) -> Int -> m ();_evalToRoot (LazySegmentTree !as !ops !height) !iLeaf = do { let { !leafVertex = iLeaf + nVerts `div` 2}; forM_ [1 .. pred height] $ \ iParent -> do { let { !vertex = nthParent leafVertex iParent}; let { !_ = dbgAssert (vertex > 0) "_evalToRoot"}; !aL' <- mact <$> UM.read ops (childL vertex) <*> GM.read as (childL vertex); !aR' <- mact <$> UM.read ops (childR vertex) <*> GM.read as (childR vertex); GM.write as vertex $! aL' <> aR'}} where { !nVerts = GM.length as; nthParent !leafVertex !nth = shiftR leafVertex nth; childL !vertex = shiftL vertex 1; childR !vertex = shiftL vertex 1 .|. 1};type SizedList = (Int, [Int]);compareSL :: SizedList -> SizedList -> Ordering;compareSL (!len1, !xs1) (!len2, !xs2) | len1 > len2 = GT | len1 < len2 = LT | otherwise = inner xs1 xs2 where { inner [] [] = EQ; inner (y1 : ys1) (y2 : ys2) = case compare y1 y2 of { EQ -> inner ys1 ys2; c -> c}; inner _ [] = error "unreachable: `compareSL`"; inner [] _ = error "unreachable: `compareSL`"};maxSL :: SizedList -> SizedList -> SizedList;maxSL sl1 sl2 = case compareSL sl1 sl2 of { GT -> sl1; _ -> sl2};nullSL :: SizedList -> Bool;nullSL = null . snd;emptySL :: SizedList;emptySL = (0, []);consSL :: SizedList -> Int -> SizedList;consSL (!len, !xs) !x = (len + 1, x : xs);msbOf :: Int -> Int;msbOf !x = 63 - countLeadingZeros x;lsbOf :: Int -> Int;lsbOf = countTrailingZeros;powersetM_ :: (Bits a, Num a, Monad m) => a -> (a -> m ()) -> m ();powersetM_ !is0 !act = act2 is0 where { act2 !is = do { act is; unless (is == 0) (act2 (is0 .&. (is - 1)))}};powerset :: (Bits a, Num a) => a -> [a];powerset !a = a : unfoldr f a where { f 0 = Nothing; f !x = Just . dupe $! a .&. (x - 1)};powersetU :: (Bits a, Num a, U.Unbox a) => a -> U.Vector a;powersetU !x0 = U.unfoldrExactN n f x0 where { !n = bit (popCount x0); f !x = (x, (x - 1) .&. x0)};class SafeList v where { type SafeListElem v; headMay :: v -> Maybe (SafeListElem v); lastMay :: v -> Maybe (SafeListElem v); headOr :: SafeListElem v -> v -> SafeListElem v; lastOr :: SafeListElem v -> v -> SafeListElem v; minimumMay :: v -> Maybe (SafeListElem v); maximumMay :: v -> Maybe (SafeListElem v); minimumOr :: SafeListElem v -> v -> SafeListElem v; maximumOr :: SafeListElem v -> v -> SafeListElem v};instance (Ord a) => SafeList [a] where { type SafeListElem [a] = a; headMay [] = Nothing; headMay (x : _) = Just x; lastMay [] = Nothing; lastMay xs = Just $ last xs; headOr x0 [] = x0; headOr _ xs = head xs; lastOr x0 [] = x0; lastOr _ xs = last xs; minimumMay [] = Nothing; minimumMay xs = Just $ minimum xs; maximumMay [] = Nothing; maximumMay xs = Just $ maximum xs; minimumOr x0 [] = x0; minimumOr _ xs = minimum xs; maximumOr x0 [] = x0; maximumOr _ xs = maximum xs};instance (Ord a) => SafeList (V.Vector a) where { type SafeListElem (V.Vector a) = a; headMay xs | G.null xs = Nothing | otherwise = Just $ G.unsafeHead xs; lastMay xs | G.null xs = Nothing | otherwise = Just $ G.unsafeLast xs; headOr x0 xs | G.null xs = x0 | otherwise = G.unsafeHead xs; lastOr x0 xs | G.null xs = x0 | otherwise = G.unsafeLast xs; minimumMay xs | G.null xs = Nothing | otherwise = Just $ G.minimum xs; maximumMay xs | G.null xs = Nothing | otherwise = Just $ G.maximum xs; minimumOr x0 xs | G.null xs = x0 | otherwise = G.minimum xs; maximumOr x0 xs | G.null xs = x0 | otherwise = G.maximum xs};instance (U.Unbox a, Ord a) => SafeList (U.Vector a) where { type SafeListElem (U.Vector a) = a; headMay xs | G.null xs = Nothing | otherwise = Just $ G.unsafeHead xs; lastMay xs | G.null xs = Nothing | otherwise = Just $ G.unsafeLast xs; headOr x0 xs | G.null xs = x0 | otherwise = G.unsafeHead xs; lastOr x0 xs | G.null xs = x0 | otherwise = G.unsafeLast xs; minimumMay xs | G.null xs = Nothing | otherwise = Just $ G.minimum xs; maximumMay xs | G.null xs = Nothing | otherwise = Just $ G.maximum xs; minimumOr x0 xs | G.null xs = x0 | otherwise = G.minimum xs; maximumOr x0 xs | G.null xs = x0 | otherwise = G.maximum xs};type MultiSet = (Int, IM.IntMap Int);emptyMS :: MultiSet;emptyMS = (0, IM.empty);singletonMS :: Int -> MultiSet;singletonMS !x = (1, IM.singleton x 1);fromListMS :: [Int] -> MultiSet;fromListMS = foldl' (flip incMS) emptyMS;incMS :: Int -> MultiSet -> MultiSet;incMS !k (!n, !im) = if IM.member k im then (n, IM.insertWith (+) k 1 im) else (n + 1, IM.insert k 1 im);decMS :: Int -> MultiSet -> MultiSet;decMS !k (!n, !im) = case IM.lookup k im of { Just 1 -> (n - 1, IM.delete k im); Just _ -> (n, IM.insertWith (+) k (-1) im); Nothing -> (n, im)};memberMS :: Int -> MultiSet -> Bool;memberMS !k (!_, !im) = IM.member k im;notMemberMS :: Int -> MultiSet -> Bool;notMemberMS !k (!_, !im) = IM.notMember k im;deleteFindMinMS :: MultiSet -> (Int, MultiSet);deleteFindMinMS ms@(!_, !im) = let { !key = fst $ IM.findMin im} in (key, decMS key ms);innerMS :: MultiSet -> IM.IntMap Int;innerMS (!_, !im) = im;data MultiSetVec s = MultiSetVec (MutVar s Int) (UM.MVector s Int);showMSV :: (PrimMonad m) => MultiSetVec (PrimState m) -> m String;showMSV (MultiSetVec !nRef !mVec) = do { !n <- readMutVar nRef; !vec <- G.unsafeFreeze mVec; return $ show (n, vec)};newMSV :: (PrimMonad m) => Int -> m (MultiSetVec (PrimState m));newMSV !capacity = MultiSetVec <$> newMutVar (0 :: Int) <*> UM.replicate capacity (0 :: Int);clearMSV :: (PrimMonad m) => MultiSetVec (PrimState m) -> m ();clearMSV (MultiSetVec !nRef !mVec) = do { writeMutVar nRef 0; GM.set mVec 0};fromVecMSV :: (PrimMonad m) => Int -> U.Vector Int -> m (MultiSetVec (PrimState m));fromVecMSV !capacity !xs = do { !msv <- newMSV capacity; U.forM_ xs (incMSV msv); return msv};countMSV :: (PrimMonad m) => MultiSetVec (PrimState m) -> m Int;countMSV (MultiSetVec !nRef !_) = readMutVar nRef;nullMSV :: (PrimMonad m) => MultiSetVec (PrimState m) -> m Bool;nullMSV = fmap (== 0) . countMSV;readMSV :: (PrimMonad m) => MultiSetVec (PrimState m) -> Int -> m Int;readMSV (MultiSetVec !_ !mVec) = GM.read mVec;incMSV :: (PrimMonad m) => MultiSetVec (PrimState m) -> Int -> m ();incMSV (MultiSetVec !nRef !mVec) k = GM.read mVec k >>= \case { 0 -> do { modifyMutVar' nRef succ; GM.write mVec k 1}; !nk -> do { GM.write mVec k (nk + 1)}};decMSV :: (PrimMonad m) => MultiSetVec (PrimState m) -> Int -> m ();decMSV (MultiSetVec !nRef !mVec) k = GM.read mVec k >>= \case { 0 -> return (); 1 -> do { modifyMutVar' nRef pred; GM.write mVec k 0}; !nk -> do { GM.write mVec k (nk - 1)}};minMSV :: (PrimMonad m) => MultiSetVec (PrimState m) -> m (Maybe (Int, Int));minMSV (MultiSetVec !nRef !mVec) = readMutVar nRef >>= \case { 0 -> return Nothing; _ -> do { !vec <- G.unsafeFreeze mVec; return . fmap (\ i -> (i, vec G.! i)) $ G.findIndex (> 0) vec}};maxMSV :: (PrimMonad m) => MultiSetVec (PrimState m) -> m (Maybe (Int, Int));maxMSV (MultiSetVec !nRef !mVec) = readMutVar nRef >>= \case { 0 -> return Nothing; _ -> do { !vec <- G.unsafeFreeze mVec; return . fmap (\ i -> (i, vec G.! i)) $ G.findIndexR (> 0) vec}};unsafeFreezeMSV :: (PrimMonad m) => MultiSetVec (PrimState m) -> m (Int, U.Vector Int);unsafeFreezeMSV (MultiSetVec !nRef !mVec) = (,) <$> readMutVar nRef <*> U.unsafeFreeze mVec;class Semiring s where { (<+>) :: s -> s -> s; szero :: s; (<.>) :: s -> s -> s; sone :: s};foldP :: (Semiring a, G.Vector v a) => v a -> a;foldP = G.foldl' (<+>) szero;foldT :: (Semiring a, G.Vector v a) => v a -> a;foldT = G.foldl' (<.>) sone;newtype MaxPlus a = MaxPlus{getMaxPlus :: a} deriving (P.Prim)                                             deriving newtype (Eq, Ord, Show);newtype instance  U.MVector s (MaxPlus a) = MV_MaxPlus (P.MVector s (MaxPlus a));newtype instance  U.Vector (MaxPlus a) = V_MaxPlus (P.Vector (MaxPlus a));deriving via (U.UnboxViaPrim (MaxPlus a)) instance (P.Prim a) => GM.MVector UM.MVector (MaxPlus a);deriving via (U.UnboxViaPrim (MaxPlus a)) instance (P.Prim a) => G.Vector U.Vector (MaxPlus a);instance (P.Prim a) => U.Unbox (MaxPlus a);instance (Num a, Bounded a, Ord a) => Semiring (MaxPlus a) where { {-# INLINE (<+>) #-}; (MaxPlus x1) <+> (MaxPlus x2) = MaxPlus (x1 `max` x2); {-# INLINE szero #-}; szero = MaxPlus minBound; {-# INLINE (<.>) #-}; (MaxPlus x1) <.> (MaxPlus x2) = MaxPlus (x1 + x2); {-# INLINE sone #-}; sone = MaxPlus 0};newtype MinPlus a = MinPlus{getMinPlus :: a} deriving (P.Prim)                                             deriving newtype (Eq, Ord, Show);newtype instance  U.MVector s (MinPlus a) = MV_MinPlus (P.MVector s (MinPlus a));newtype instance  U.Vector (MinPlus a) = V_MinPlus (P.Vector (MinPlus a));deriving via (U.UnboxViaPrim (MinPlus a)) instance (P.Prim a) => GM.MVector UM.MVector (MinPlus a);deriving via (U.UnboxViaPrim (MinPlus a)) instance (P.Prim a) => G.Vector U.Vector (MinPlus a);instance (P.Prim a) => U.Unbox (MinPlus a);instance (Num a, Bounded a, Ord a) => Semiring (MinPlus a) where { {-# INLINE (<+>) #-}; (MinPlus x1) <+> (MinPlus x2) = MinPlus (x1 `min` x2); {-# INLINE szero #-}; szero = MinPlus maxBound; {-# INLINE (<.>) #-}; (MinPlus x1) <.> (MinPlus x2) = MinPlus (x1 + x2); {-# INLINE sone #-}; sone = MinPlus 0};newtype Boolean = Boolean{getBoolean :: Bool} deriving newtype (Eq, Ord, Show);instance U.IsoUnbox Boolean Bool where { {-# INLINE toURepr #-}; toURepr (Boolean b) = b; {-# INLINE fromURepr #-}; fromURepr = Boolean};newtype instance  U.MVector s Boolean = MV_Foo (U.MVector s Bool);newtype instance  U.Vector Boolean = V_Foo (U.Vector Bool);deriving via (Boolean `U.As` Bool) instance GM.MVector UM.MVector Boolean;deriving via (Boolean `U.As` Bool) instance G.Vector U.Vector Boolean;instance U.Unbox Boolean;instance Semiring Boolean where { {-# INLINE (<+>) #-}; (Boolean x1) <+> (Boolean x2) = Boolean (x1 || x2); {-# INLINE szero #-}; szero = Boolean False; {-# INLINE (<.>) #-}; (Boolean x1) <.> (Boolean x2) = Boolean (x1 && x2); {-# INLINE sone #-}; sone = Boolean True};class FromVec a where { type FromVecInput a; type FromVecItem a; fromVec :: (G.Vector v (FromVecInput a)) => v (FromVecInput a) -> a; fromVecWith :: (G.Vector v (FromVecInput a)) => (FromVecItem a -> FromVecItem a -> FromVecItem a) -> v (FromVecInput a) -> a; fromVecWith _ = fromVec};instance FromVec (IM.IntMap a) where { type FromVecInput (IM.IntMap a) = (Int, a); type FromVecItem (IM.IntMap a) = a; fromVec = G.foldl' (\ im (!k, !v) -> IM.insert k v im) IM.empty; fromVecWith !f = G.foldl' (\ im (!k, !v) -> IM.insertWith f k v im) IM.empty};instance (Ord k) => FromVec (M.Map k a) where { type FromVecInput (M.Map k a) = (k, a); type FromVecItem (M.Map k a) = a; fromVec = G.foldl' (\ im (!k, !v) -> M.insert k v im) M.empty; fromVecWith !f = G.foldl' (\ im (!k, !v) -> M.insertWith f k v im) M.empty};instance FromVec IS.IntSet where { type FromVecInput IS.IntSet = Int; type FromVecItem IS.IntSet = Int; fromVec = G.foldl' (flip IS.insert) IS.empty; fromVecWith _ = fromVec};instance (Ord a) => FromVec (S.Set a) where { type FromVecInput (S.Set a) = a; type FromVecItem (S.Set a) = a; fromVec = G.foldl' (flip S.insert) S.empty; fromVecWith _ = fromVec};instance (Ord a) => FromVec (H.Heap a) where { type FromVecInput (H.Heap a) = a; type FromVecItem (H.Heap a) = a; fromVec = G.foldl' (flip H.insert) H.empty; fromVecWith _ = fromVec};instance FromVec MultiSet where { type FromVecInput MultiSet = Int; type FromVecItem MultiSet = Int; fromVec = G.foldl' (flip incMS) emptyMS; fromVecWith _ = fromVec};fromVecIM :: (G.Vector v (Int, a)) => v (Int, a) -> IM.IntMap a;fromVecIM = fromVec;fromVecWithIM :: (G.Vector v (Int, a)) => (a -> a -> a) -> v (Int, a) -> IM.IntMap a;fromVecWithIM = fromVecWith;fromVecM :: (G.Vector v (k, a), Ord k) => v (k, a) -> M.Map k a;fromVecM = fromVec;fromVecWithM :: (G.Vector v (k, a), Ord k) => (a -> a -> a) -> v (k, a) -> M.Map k a;fromVecWithM = fromVecWith;fromVecIS :: (G.Vector v Int) => v Int -> IS.IntSet;fromVecIS = fromVec;fromVecS :: (Ord a, G.Vector v a) => v a -> S.Set a;fromVecS = fromVec;fromVecH :: (Ord a, G.Vector v a) => v a -> H.Heap a;fromVecH = fromVec;class (Ix i, U.Unbox i) => Unindex i where { unindex :: (i, i) -> Int -> i};instance Unindex Int where { unindex _ !v = v};instance Unindex (Int, Int) where { unindex ((!y0, !x0), (!_, !x1)) !yx = let { !w = x1 - x0 + 1; (!dy, !dx) = yx `quotRem` w} in (y0 + dy, x0 + dx)};instance Unindex (Int, Int, Int) where { unindex ((!z0, !y0, !x0), (!_, !y1, !x1)) !zyx = let { !h = y1 - y0 + 1; !w = x1 - x0 + 1; (!dz, !yx) = zyx `quotRem` (h * w); (!dy, !dx) = yx `quotRem` w} in (z0 + dz, y0 + dy, x0 + dx)};instance Unindex (Int, Int, Int, Int) where { unindex ((!b3, !b2, !b1, !b0), (!_, !x2, !x1, !x0)) !pos3 = let { !w2 = x2 - b2 + 1; !w1 = x1 - b1 + 1; !w0 = x0 - b0 + 1; (!y3, !pos2) = pos3 `quotRem` (w2 * w1 * w0); (!y2, !pos1) = pos2 `quotRem` (w1 * w0); (!y1, !y0) = pos1 `quotRem` w0} in (b3 + y3, b2 + y2, b1 + y1, b0 + y0)};instance Unindex ((Int, Int), (Int, Int)) where { unindex (((!b3, !b2), (!b1, !b0)), ((!_, !x2), (!x1, !x0))) !pos3 = let { !w2 = x2 - b2 + 1; !w1 = x1 - b1 + 1; !w0 = x0 - b0 + 1; (!y3, !pos2) = pos3 `quotRem` (w2 * w1 * w0); (!y2, !pos1) = pos2 `quotRem` (w1 * w0); (!y1, !y0) = pos1 `quotRem` w0} in ((b3 + y3, b2 + y2), (b1 + y1, b0 + y0))};zeroBnd1 :: Int -> (Int, Int);zeroBnd1 w = (0, w - 1);zeroBnd2 :: (Int, Int) -> ((Int, Int), (Int, Int));zeroBnd2 (!h, !w) = ((0, 0), (h - 1, w - 1));zeroBnd3 :: (Int, Int, Int) -> ((Int, Int, Int), (Int, Int, Int));zeroBnd3 (!d, !h, !w) = ((0, 0, 0), (d - 1, h - 1, w - 1));data IxVector i v = IxVector{boundsIV :: !(i, i), vecIV :: !v} deriving (Show, Eq);type IxUVector i a = IxVector i (U.Vector a);type IxMUVector i s a = IxVector i (UM.MVector s a);{-# INLINE (@!) #-};(@!) :: (HasCallStack, Ix i, G.Vector v a) => IxVector i (v a) -> i -> a;(@!) IxVector{..} i = vecIV G.! index boundsIV i;{-# INLINE (@!!) #-};(@!!) :: (Ix i, G.Vector v a) => IxVector i (v a) -> i -> a;(@!!) IxVector{..} i = G.unsafeIndex vecIV (unsafeIndex boundsIV i);{-# INLINE (@!?) #-};(@!?) :: (HasCallStack, Ix i, G.Vector v a) => IxVector i (v a) -> i -> Maybe a;(@!?) IxVector{..} i | inRange boundsIV i = Just (vecIV G.! index boundsIV i) | otherwise = Nothing;{-# INLINE (@!!?) #-};(@!!?) :: (Ix i, G.Vector v a) => IxVector i (v a) -> i -> Maybe a;(@!!?) IxVector{..} i | inRange boundsIV i = Just (G.unsafeIndex vecIV (unsafeIndex boundsIV i)) | otherwise = Nothing;{-# INLINE mapIV #-};mapIV :: (U.Unbox a, U.Unbox b) => (a -> b) -> IxVector i (U.Vector a) -> IxVector i (U.Vector b);mapIV !f !vec = IxVector bnd $ U.map f (vecIV vec) where { !bnd = boundsIV vec};{-# INLINE imapIV #-};imapIV :: (Unindex i, U.Unbox a, U.Unbox b) => (i -> a -> b) -> IxVector i (U.Vector a) -> IxVector i (U.Vector b);imapIV !f !vec = IxVector bnd $ U.imap wrapper (vecIV vec) where { !bnd = boundsIV vec; wrapper i = f (unindex bnd i)};{-# INLINE zipWithIV #-};zipWithIV :: (U.Unbox a, U.Unbox b, U.Unbox c) => (a -> b -> c) -> IxVector i (U.Vector a) -> IxVector i (U.Vector b) -> IxVector i (U.Vector c);zipWithIV !f !vec1 !vec2 = IxVector bnd $ U.zipWith f (vecIV vec1) (vecIV vec2) where { !bnd = boundsIV vec1};{-# INLINE accumulateIV #-};accumulateIV :: (Ix i, U.Unbox i, U.Unbox a, U.Unbox b) => (a -> b -> a) -> IxVector i (U.Vector a) -> IxVector i (U.Vector (i, b)) -> IxVector i (U.Vector a);accumulateIV !f !vec0 !commands = let { !input1d = U.map (first (index bnd)) (vecIV commands); !vec1d = U.accumulate f (vecIV vec0) input1d} in IxVector bnd vec1d where { !bnd = boundsIV vec0; !_ = dbgAssert (boundsIV vec0 == boundsIV commands)};{-# INLINE createIV #-};createIV :: (G.Vector v a) => (forall s . ST s (IxVector i (G.Mutable v s a))) -> IxVector i (v a);createIV st = runST $ do { iv <- st; let { bnd = boundsIV iv}; IxVector bnd <$> G.unsafeFreeze (vecIV iv)};{-# INLINE generateIV #-};generateIV :: (Unindex i, U.Unbox a) => (i, i) -> (i -> a) -> IxUVector i a;generateIV bnd f = IxVector bnd $ U.generate (rangeSize bnd) (f . unindex bnd);{-# INLINE constructIV #-};constructIV :: (Unindex i, U.Unbox a) => (i, i) -> (IxUVector i a -> i -> a) -> IxUVector i a;constructIV bnd f = IxVector bnd $ U.constructN (rangeSize bnd) $ \ sofar -> f (IxVector bnd sofar) $! unindex bnd (G.length sofar);{-# INLINE thawIV #-};thawIV :: (PrimMonad m, G.Vector v a) => IxVector i (v a) -> m (IxVector i (G.Mutable v (PrimState m) a));thawIV iv = IxVector (boundsIV iv) <$> G.thaw (vecIV iv);{-# INLINE unsafeThawIV #-};unsafeThawIV :: (PrimMonad m, G.Vector v a) => IxVector i (v a) -> m (IxVector i (G.Mutable v (PrimState m) a));unsafeThawIV iv = IxVector (boundsIV iv) <$> G.thaw (vecIV iv);{-# INLINE freezeIV #-};freezeIV :: (PrimMonad m, G.Vector v a) => IxVector i (G.Mutable v (PrimState m) a) -> m (IxVector i (v a));freezeIV iv = IxVector (boundsIV iv) <$> G.freeze (vecIV iv);{-# INLINE unsafeFreezeIV #-};unsafeFreezeIV :: (PrimMonad m, G.Vector v a) => IxVector i (G.Mutable v (PrimState m) a) -> m (IxVector i (v a));unsafeFreezeIV iv = IxVector (boundsIV iv) <$> G.unsafeFreeze (vecIV iv);{-# INLINE csum2D #-};csum2D :: (HasCallStack, Num a, U.Unbox a) => IxUVector (Int, Int) a -> IxUVector (Int, Int) a;csum2D !gr = IxVector bnd $ U.constructN (rangeSize bnd) $ \ sofar -> case unindex bnd (G.length sofar) of { (0, _) -> 0; (_, 0) -> 0; (!y, !x) -> v0 + fromY + fromX - fromD where { v0 = gr @! (y - 1, x - 1); fromY = IxVector bnd sofar @! (y - 1, x); fromX = IxVector bnd sofar @! (y, x - 1); fromD = IxVector bnd sofar @! (y - 1, x - 1)}} where { !bnd = second (both (+ 1)) (boundsIV gr)};{-# INLINE (@+!) #-};(@+!) :: (HasCallStack, Num a, U.Unbox a) => IxUVector (Int, Int) a -> ((Int, Int), (Int, Int)) -> a;(@+!) !csum ((!y1, !x1), (!y2, !x2)) = s1 + s4 - s2 - s3 where { !s1 = csum @! (y2 + 1, x2 + 1); !s2 = csum @! (y1, x2 + 1); !s3 = csum @! (y2 + 1, x1); !s4 = csum @! (y1, x1)};{-# INLINE readIV #-};readIV :: (HasCallStack, Ix i, PrimMonad m, GM.MVector v a) => IxVector i (v (PrimState m) a) -> i -> m a;readIV IxVector{..} i = GM.read vecIV (index boundsIV i);{-# INLINE readMayIV #-};readMayIV :: (HasCallStack, Ix i, PrimMonad m, GM.MVector v a) => IxVector i (v (PrimState m) a) -> i -> m (Maybe a);readMayIV IxVector{..} i | not (inRange boundsIV i) = return Nothing | otherwise = Just <$> GM.read vecIV (index boundsIV i);{-# INLINE unsafeReadIV #-};unsafeReadIV :: (Ix i, PrimMonad m, GM.MVector v a) => IxVector i (v (PrimState m) a) -> i -> m a;unsafeReadIV IxVector{..} i = GM.unsafeRead vecIV (unsafeIndex boundsIV i);{-# INLINE writeIV #-};writeIV :: (HasCallStack, Ix i, PrimMonad m, GM.MVector v a) => IxVector i (v (PrimState m) a) -> i -> a -> m ();writeIV IxVector{..} i = GM.write vecIV (index boundsIV i);{-# INLINE unsafeWriteIV #-};unsafeWriteIV :: (Ix i, PrimMonad m, GM.MVector v a) => IxVector i (v (PrimState m) a) -> i -> a -> m ();unsafeWriteIV IxVector{..} i = GM.unsafeWrite vecIV (unsafeIndex boundsIV i);{-# INLINE modifyIV #-};modifyIV :: (HasCallStack, Ix i, PrimMonad m, GM.MVector v a) => IxVector i (v (PrimState m) a) -> (a -> a) -> i -> m ();modifyIV IxVector{..} !alter i = GM.modify vecIV alter (index boundsIV i);{-# INLINE unsafeModifyIV #-};unsafeModifyIV :: (Ix i, PrimMonad m, GM.MVector v a) => IxVector i (v (PrimState m) a) -> (a -> a) -> i -> m ();unsafeModifyIV IxVector{..} !alter i = GM.unsafeModify vecIV alter (unsafeIndex boundsIV i);{-# INLINE modifyMIV #-};modifyMIV :: (HasCallStack, Ix i, PrimMonad m, GM.MVector v a) => IxVector i (v (PrimState m) a) -> (a -> m a) -> i -> m ();modifyMIV IxVector{..} !alter i = GM.modifyM vecIV alter (index boundsIV i);{-# INLINE unsafeModifyMIV #-};unsafeModifyMIV :: (Ix i, PrimMonad m, GM.MVector v a) => IxVector i (v (PrimState m) a) -> (a -> m a) -> i -> m ();unsafeModifyMIV IxVector{..} !alter i = GM.unsafeModifyM vecIV alter (unsafeIndex boundsIV i);{-# INLINE swapIV #-};swapIV :: (HasCallStack, Ix i, PrimMonad m, GM.MVector v a) => IxVector i (v (PrimState m) a) -> i -> i -> m ();swapIV IxVector{..} !i1 !i2 = GM.swap vecIV (index boundsIV i1) (index boundsIV i2);{-# INLINE unsafeSwapIV #-};unsafeSwapIV :: (Ix i, PrimMonad m, GM.MVector v a) => IxVector i (v (PrimState m) a) -> i -> i -> m ();unsafeSwapIV IxVector{..} !i1 !i2 = GM.unsafeSwap vecIV (unsafeIndex boundsIV i1) (unsafeIndex boundsIV i2);imos2DIV :: (HasCallStack) => IxVector (Int, Int) (U.Vector Int) -> IxVector (Int, Int) (U.Vector Int);imos2DIV seeds@IxVector{boundsIV} = IxVector boundsIV $ U.create $ do { !vec <- IxVector boundsIV <$> U.thaw (vecIV seeds); let { (!minY, !minX) = fst boundsIV}; forM_ (range boundsIV) $ \ (!y, !x) -> do { !v <- if x == minX then return 0 else readIV vec (y, x - 1); modifyIV vec (+ v) (y, x)}; forM_ (range boundsIV) $ \ (!x, !y) -> do { !v <- if y == minY then return 0 else readIV vec (y - 1, x); modifyIV vec (+ v) (y, x)}; return $ vecIV vec};data Buffer s a = Buffer{bufferVars :: !(UM.MVector s Int), internalBuffer :: !(UM.MVector s a), internalBufferSize :: !Int};_bufferFrontPos :: Int;_bufferFrontPos = 0;_bufferBackPos :: Int;_bufferBackPos = 1;newBuffer :: (U.Unbox a, PrimMonad m) => Int -> m (Buffer (PrimState m) a);newBuffer n = Buffer <$> UM.replicate 2 0 <*> UM.unsafeNew n <*> pure n;type Stack s a = Buffer s a;newBufferAsStack :: (U.Unbox a, PrimMonad m) => Int -> m (Buffer (PrimState m) a);newBufferAsStack n = Buffer <$> UM.replicate 2 0 <*> UM.unsafeNew n <*> pure n;type Queue s a = Buffer s a;newBufferAsQueue :: (U.Unbox a, PrimMonad m) => Int -> m (Buffer (PrimState m) a);newBufferAsQueue n = Buffer <$> UM.replicate 2 0 <*> UM.unsafeNew n <*> pure n;type Deque s a = Buffer s a;newBufferAsDeque :: (U.Unbox a, PrimMonad m) => Int -> m (Buffer (PrimState m) a);newBufferAsDeque n = Buffer <$> UM.replicate 2 n <*> UM.unsafeNew (2 * n) <*> pure (2 * n);lengthBuffer :: (PrimMonad m) => Buffer (PrimState m) a -> m Int;lengthBuffer Buffer{bufferVars} = liftA2 (-) (UM.unsafeRead bufferVars _bufferBackPos) (UM.unsafeRead bufferVars _bufferFrontPos);{-# INLINE lengthBuffer #-};nullBuffer :: (PrimMonad m) => Buffer (PrimState m) a -> m Bool;nullBuffer = fmap (== 0) . lengthBuffer;{-# INLINE nullBuffer #-};clearBuffer :: (PrimMonad m) => Buffer (PrimState m) a -> m ();clearBuffer Buffer{bufferVars} = do { UM.unsafeWrite bufferVars _bufferFrontPos 0; UM.unsafeWrite bufferVars _bufferBackPos 0};freezeBuffer :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> m (U.Vector a);freezeBuffer Buffer{bufferVars, internalBuffer} = do { f <- UM.unsafeRead bufferVars _bufferFrontPos; b <- UM.unsafeRead bufferVars _bufferBackPos; U.freeze $ UM.unsafeSlice f (b - f) internalBuffer};unsafeFreezeBuffer :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> m (U.Vector a);unsafeFreezeBuffer Buffer{bufferVars, internalBuffer} = do { f <- UM.unsafeRead bufferVars _bufferFrontPos; b <- UM.unsafeRead bufferVars _bufferBackPos; U.unsafeFreeze $ UM.unsafeSlice f (b - f) internalBuffer};freezeInternalBuffer :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> m (U.Vector a);freezeInternalBuffer Buffer{bufferVars, internalBuffer} = do { b <- UM.unsafeRead bufferVars _bufferBackPos; U.freeze $ UM.unsafeSlice 0 b internalBuffer};unsafeFreezeInternalBuffer :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> m (U.Vector a);unsafeFreezeInternalBuffer Buffer{bufferVars, internalBuffer} = do { b <- UM.unsafeRead bufferVars _bufferBackPos; U.unsafeFreeze $ UM.unsafeSlice 0 b internalBuffer};popFront :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> m (Maybe a);popFront Buffer{bufferVars, internalBuffer} = do { f <- UM.unsafeRead bufferVars _bufferFrontPos; b <- UM.unsafeRead bufferVars _bufferBackPos; if f < b then do { UM.unsafeWrite bufferVars _bufferFrontPos (f + 1); pure <$> UM.unsafeRead internalBuffer f} else return Nothing};{-# INLINE popFront #-};popFront_ :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> m ();popFront_ = void . popFront;{-# INLINE popFront_ #-};viewFront :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> m (Maybe a);viewFront Buffer{bufferVars, internalBuffer} = do { f <- UM.unsafeRead bufferVars _bufferFrontPos; b <- UM.unsafeRead bufferVars _bufferBackPos; if f < b then pure <$> UM.unsafeRead internalBuffer f else return Nothing};{-# INLINE viewFront #-};popBack :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> m (Maybe a);popBack Buffer{bufferVars, internalBuffer} = do { f <- UM.unsafeRead bufferVars _bufferFrontPos; b <- UM.unsafeRead bufferVars _bufferBackPos; if f < b then do { UM.unsafeWrite bufferVars _bufferBackPos (b - 1); pure <$> UM.unsafeRead internalBuffer (b - 1)} else return Nothing};{-# INLINE popBack #-};popBack_ :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> m ();popBack_ = void . popBack;{-# INLINE popBack_ #-};viewBack :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> m (Maybe a);viewBack Buffer{bufferVars, internalBuffer} = do { f <- UM.unsafeRead bufferVars _bufferFrontPos; b <- UM.unsafeRead bufferVars _bufferBackPos; if f < b then pure <$> UM.unsafeRead internalBuffer (b - 1) else return Nothing};{-# INLINE viewBack #-};pushFront :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> a -> m ();pushFront Buffer{bufferVars, internalBuffer} x = do { f <- UM.unsafeRead bufferVars _bufferFrontPos; UM.unsafeWrite bufferVars _bufferFrontPos (f - 1); assert (f > 0) $ do { UM.unsafeWrite internalBuffer (f - 1) x}};{-# INLINE pushFront #-};pushBack :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> a -> m ();pushBack Buffer{bufferVars, internalBuffer, internalBufferSize} x = do { b <- UM.unsafeRead bufferVars _bufferBackPos; UM.unsafeWrite bufferVars _bufferBackPos (b + 1); assert (b < internalBufferSize) $ do { UM.unsafeWrite internalBuffer b x}};{-# INLINE pushBack #-};pushFronts :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> U.Vector a -> m ();pushFronts Buffer{bufferVars, internalBuffer} vec = do { let { n = U.length vec}; f <- UM.unsafeRead bufferVars _bufferFrontPos; UM.unsafeWrite bufferVars _bufferFrontPos (f - n); assert (n <= f) $ do { U.unsafeCopy (UM.unsafeSlice (f - n) n internalBuffer) vec}};{-# INLINE pushFronts #-};pushBacks :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> U.Vector a -> m ();pushBacks Buffer{bufferVars, internalBuffer, internalBufferSize} vec = do { let { n = U.length vec}; b <- UM.unsafeRead bufferVars _bufferBackPos; UM.unsafeWrite bufferVars _bufferBackPos (b + n); assert (b + n - 1 < internalBufferSize) $ do { U.unsafeCopy (UM.unsafeSlice b n internalBuffer) vec}};{-# INLINE pushBacks #-};viewFrontN :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> Int -> m (Maybe a);viewFrontN Buffer{..} i = do { !f <- UM.unsafeRead bufferVars _bufferFrontPos; !b <- UM.unsafeRead bufferVars _bufferBackPos; if inRange (f, b - 1) (f + i) then Just <$> UM.read internalBuffer (f + i) else return Nothing};{-# INLINE viewFrontN #-};viewBackN :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> Int -> m (Maybe a);viewBackN Buffer{..} i = do { !f <- UM.unsafeRead bufferVars _bufferFrontPos; !b <- UM.unsafeRead bufferVars _bufferBackPos; if inRange (f, b - 1) (b - 1 - i) then Just <$> UM.read internalBuffer (b - 1 - i) else return Nothing};{-# INLINE viewBackN #-};chunksOfG :: (G.Vector v a) => Int -> v a -> V.Vector (v a);chunksOfG k xs0 = V.unfoldrExactN n step xs0 where { n = (G.length xs0 + k - 1) `div` k; step xs = (G.take k xs, G.drop k xs)};{-# INLINE slideMinIndicesOn #-};slideMinIndicesOn :: (G.Vector v a, Ord b) => (a -> b) -> Int -> v a -> U.Vector Int;slideMinIndicesOn wrap len xs = runST $ do { !buf <- newBufferAsQueue (G.length xs); G.generateM (G.length xs) $ \ i -> do { fix $ \ loop -> do { whenM (maybe False (<= i - len) <$> viewFront buf) $ do { void $ popFront buf; loop}}; fix $ \ loop -> do { whenM (maybe False ((< wrap (xs G.! i)) . wrap . (xs G.!)) <$> viewBack buf) $ do { void $ popBack buf; loop}}; pushBack buf i; fromJust <$> viewFront buf}};{-# INLINE slideMinIndices #-};slideMinIndices :: Int -> U.Vector Int -> U.Vector Int;slideMinIndices = slideMinIndicesOn id;{-# INLINE slideMaxIndices #-};slideMaxIndices :: Int -> U.Vector Int -> U.Vector Int;slideMaxIndices = slideMinIndicesOn Down;data AdhocGraph m w = AdhocGraph{undefAG :: !w, nVertsAG :: !Int, visAG :: !(UM.MVector (PrimState m) Bool), distAG :: !(UM.MVector (PrimState m) w), parentAG :: !(UM.MVector (PrimState m) Int), adjAG :: !(Vertex -> U.Vector Vertex), adjWAG :: !(Vertex -> U.Vector (Vertex, w))};data AdhocMethod m w = AdhocMethod{markRootAM :: !(AdhocGraph m w -> Vertex -> w -> m ()), markAM :: !(AdhocGraph m w -> Vertex -> (Vertex, w) -> m ()), unmarkAM :: !(AdhocGraph m w -> Vertex -> (Vertex, w) -> m ()), wfilterAM :: !(AdhocGraph m w -> Vertex -> (Vertex, w) -> m Bool)};defaultMarkRootAM :: (PrimMonad m, U.Unbox w) => AdhocGraph m w -> Vertex -> w -> m ();defaultMarkRootAM ag v w = do { UM.write (distAG ag) v w};defaultMarkAM :: (PrimMonad m, U.Unbox w, Eq w, Num w) => (AdhocGraph m w -> Vertex -> (Vertex, w) -> m ());defaultMarkAM ag v1 (!v2, !dw2) = do { w1 <- UM.read (distAG ag) v1; let { !_ = dbgAssert (w1 /= undefAG ag) $ "v1 has undefiend distance: " ++ show v1 ++ " -> " ++ show v2}; UM.write (distAG ag) v2 $! w1 + dw2};defaultUnmarkAM :: (PrimMonad m, U.Unbox w) => (AdhocGraph m w -> Vertex -> (Vertex, w) -> m ());defaultUnmarkAM ag _ (!v2, !_) = do { UM.write (distAG ag) v2 (undefAG ag)};defaultWFilterAM :: (PrimMonad m, U.Unbox w, Eq w) => (AdhocGraph m w -> Vertex -> (Vertex, w) -> m Bool);defaultWFilterAM ag _ (!v2, !_) = do { (== undefAG ag) <$> UM.read (distAG ag) v2};amDefault :: (PrimMonad m, U.Unbox w, Num w, Eq w) => AdhocMethod m w;amDefault = AdhocMethod{markRootAM = defaultMarkRootAM, markAM = defaultMarkAM, unmarkAM = defaultUnmarkAM, wfilterAM = defaultWFilterAM};amDefaultInt :: (PrimMonad m) => AdhocMethod m Int;amDefaultInt = amDefault;data AdhocGraphArgs w = AdhocGraphArgs{undefAGA :: !w, nVertsAGA :: !Int, distAGA :: !Bool, visAGA :: !Bool, parentAGA :: !Bool, adjAGA :: !(Vertex -> U.Vector Vertex), adjWAGA :: !(Vertex -> U.Vector (Vertex, w))};agaDefaultUnit :: AdhocGraphArgs ();agaDefaultUnit = AdhocGraphArgs{undefAGA = (), nVertsAGA = 0, distAGA = False, visAGA = False, parentAGA = False, adjAGA = const U.empty, adjWAGA = const U.empty};agaDefaultInt :: AdhocGraphArgs Int;agaDefaultInt = AdhocGraphArgs{undefAGA = -1 :: Int, nVertsAGA = 0, distAGA = False, visAGA = True, parentAGA = False, adjAGA = const U.empty, adjWAGA = const U.empty};newAg :: (PrimMonad m, U.Unbox w) => AdhocGraphArgs w -> m (AdhocGraph m w);newAg AdhocGraphArgs{..} = do { !vis <- UM.replicate (bool 0 nVertsAGA visAGA) False; !dist <- UM.replicate (bool 0 nVertsAGA distAGA) undefAGA; !parent <- UM.replicate (bool 0 nVertsAGA visAGA) (-1 :: Vertex); return $ AdhocGraph undefAGA nVertsAGA vis dist parent adjAGA adjWAGA};{-# INLINE adjWFilterAM #-};adjWFilterAM :: (PrimMonad m, U.Unbox w) => AdhocMethod m w -> AdhocGraph m w -> Vertex -> m (U.Vector (Vertex, w));adjWFilterAM AdhocMethod{..} ag@AdhocGraph{..} !v1 = U.filterM (wfilterAM ag v1) $ adjWAG v1;{-# INLINE markScopeAM #-};markScopeAM :: (PrimMonad m) => AdhocMethod m w -> AdhocGraph m w -> Vertex -> (Vertex, w) -> m () -> m ();markScopeAM AdhocMethod{..} !ag !v1 (!v2, !w2) !f = do { markAM ag v1 (v2, w2); f; unmarkAM ag v1 (v2, w2)};{-# INLINE distFilterAG #-};distFilterAG :: (PrimMonad m, U.Unbox w, Ord w) => AdhocGraph m w -> U.Vector Vertex -> m (U.Vector Vertex);distFilterAG AdhocGraph{..} = U.filterM (fmap (== undefAG) . UM.read distAG) where { !_ = dbgAssert (not (GM.null distAG)) "`distAG` is null"};{-# INLINE distFilterWAG #-};distFilterWAG :: (PrimMonad m, U.Unbox w, Ord w) => AdhocGraph m w -> U.Vector (Vertex, w) -> m (U.Vector (Vertex, w));distFilterWAG AdhocGraph{..} = U.filterM (fmap (== undefAG) . UM.read distAG . fst) where { !_ = dbgAssert (not (GM.null distAG)) "`distAG` is null"};{-# INLINE visFilterAG #-};visFilterAG :: (PrimMonad m) => AdhocGraph m w -> U.Vector Vertex -> m (U.Vector Vertex);visFilterAG AdhocGraph{..} = U.filterM (fmap not . UM.read visAG) where { !_ = dbgAssert (not (GM.null visAG)) "`visAG` is null"};{-# INLINE markDistAG #-};markDistAG :: (PrimMonad m, U.Unbox w, Num w) => AdhocGraph m w -> Vertex -> (Vertex, w) -> m ();markDistAG ag@AdhocGraph{..} !v1 (!v2, !dw2) = do { !w1 <- UM.read distAG v1; UM.write distAG v2 $! w1 + dw2} where { !_ = dbgAssert (not (GM.null distAG)) "`distAG` is null"};{-# INLINE markVisAG #-};markVisAG :: (PrimMonad m, U.Unbox w, Num w) => AdhocGraph m w -> Vertex -> (Vertex, w) -> m ();markVisAG ag@AdhocGraph{..} !v1 (!v2, !dw2) = do { !w1 <- UM.read distAG v1; UM.write distAG v2 $! w1 + dw2} where { !_ = dbgAssert (not (GM.null visAG)) "`visAG` is null"};{-# INLINE unmarkDistAG #-};unmarkDistAG :: (PrimMonad m, U.Unbox w) => AdhocGraph m w -> Vertex -> (Vertex, w) -> m ();unmarkDistAG AdhocGraph{..} !_v1 (!v2, !_dw2) = do { UM.write distAG v2 undefAG} where { !_ = dbgAssert (not (GM.null distAG)) "`distAG` is null"};{-# INLINE unmarkVisAG #-};unmarkVisAG :: (PrimMonad m) => AdhocGraph m w -> Vertex -> Vertex -> m ();unmarkVisAG AdhocGraph{..} !_ !v2 = do { UM.write visAG v2 False} where { !_ = dbgAssert (not (GM.null visAG)) "`visAG` is null"};{-# INLINE markParentAG #-};markParentAG :: (PrimMonad m) => AdhocGraph m w -> Vertex -> (Vertex, w) -> m ();markParentAG AdhocGraph{..} !v1 (!v2, !_) = do { UM.write parentAG v2 v1} where { !_ = dbgAssert (not (GM.null parentAG)) "`parentAG` is null"};{-# INLINE distAdjWAG #-};distAdjWAG :: (PrimMonad m, U.Unbox w, Ord w) => AdhocGraph m w -> Vertex -> m (U.Vector (Vertex, w));distAdjWAG ag@AdhocGraph{..} = distFilterWAG ag . adjWAG;dfsAG :: (PrimMonad m, U.Unbox w, Num w, Ord w) => AdhocGraph m w -> AdhocMethod m w -> Vertex -> m ();dfsAG ag AdhocMethod{..} source = do { markRootAM ag source 0; flip fix source $ \ loop !v1 -> do { ((ag `distAdjWAG` v1) >>=) . U.mapM_ $ \ (!v2, !dw2) -> do { markAM ag v1 (v2, dw2); loop v2}}};dfsAllAG :: (PrimMonad m, U.Unbox w, Num w) => AdhocGraph m w -> AdhocMethod m w -> Vertex -> m ();dfsAllAG ag am@AdhocMethod{..} source = do { markRootAM ag source 0; dfsBackAllAG ag am source};dfsBackAllAG :: (PrimMonad m, U.Unbox w) => AdhocGraph m w -> AdhocMethod m w -> Vertex -> m ();dfsBackAllAG ag am source = do { flip fix source $ \ loop !v1 -> do { (adjWFilterAM am ag v1 >>=) . U.mapM_ $ \ (!v2, !dw2) -> do { markScopeAM am ag v1 (v2, dw2) $ do { loop v2}}}};bfsAG :: (PrimMonad m, U.Unbox w, Num w, Ord w) => AdhocGraph m w -> AdhocMethod m w -> Vertex -> m ();bfsAG ag@AdhocGraph{..} AdhocMethod{..} source = do { markRootAM ag source 0; !queue <- newBufferAsDeque nVertsAG; pushBack queue source; fix $ \ loop -> do { popFront queue >>= \case { Nothing -> return (); Just v1 -> do { ((ag `distAdjWAG` v1) >>=) $ U.mapM_ $ \ (!v2, !dw2) -> do { markAM ag v1 (v2, dw2); pushBack queue v2}}}}} where { !_ = dbgAssert (not (GM.null distAG)) "`distAG` is null"};{-# INLINE pruneAdjWAG #-};pruneAdjWAG :: (PrimMonad m, U.Unbox w, Ord w, Num w) => AdhocGraph m w -> Vertex -> w -> m (U.Vector (Vertex, w));pruneAdjWAG AdhocGraph{..} !v1 !w1 = U.filterM p $ adjWAG v1 where { !_ = dbgAssert (not (GM.null distAG)) "`distAG` is null"; p (!v2, !dw2) = do { !wReserved2 <- UM.read distAG v2; let { w2' = w1 + dw2}; return $ wReserved2 == undefAG || w2' < wReserved2}};bfs01AG :: (PrimMonad m, U.Unbox w, Ord w, Num w) => AdhocGraph m w -> AdhocMethod m w -> Vertex -> m ();bfs01AG ag@AdhocGraph{..} AdhocMethod{..} source = do { markRootAM ag source 0; !queue <- newBufferAsDeque nVertsAG; pushBack queue (source, 0); fix $ \ loop -> do { popFront queue >>= \case { Nothing -> return (); Just (!v1, !w1) -> do { !w1Reserved <- UM.read distAG v1; when (w1 == w1Reserved) $ do { (pruneAdjWAG ag v1 w1 >>=) . U.mapM_ $ \ (!v2, !dw2) -> do { markAM ag v1 (v2, dw2); !w2 <- GM.read distAG v2; if dw2 == 0 then pushFront queue (v2, w2) else pushBack queue (v2, w2)}}; loop}}}} where { !_ = dbgAssert (not (GM.null distAG)) "`distAG` is null"};djAG :: (PrimMonad m, U.Unbox w, Ord w, Num w) => AdhocGraph m w -> AdhocMethod m w -> Vertex -> m ();djAG ag@AdhocGraph{..} AdhocMethod{..} source = do { UM.write distAG source 0; let { !heap0 = H.singleton $ H.Entry 0 source}; flip fix heap0 $ \ loop !heap -> case H.uncons heap of { Nothing -> return (); Just (H.Entry !w1 !v1, heap') -> do { loop <=< ((pruneAdjWAG ag v1 w1 >>=) . (`U.foldM'` heap')) $ \ h (!v2, !dw2) -> do { markAM ag v1 (v2, dw2); !w2 <- GM.read distAG v2; return $ H.insert (H.Entry w2 v2) h}}}} where { !_ = dbgAssert (not (GM.null distAG)) "`distAG` is null"};data Dinic s c = Dinic{nVertsD :: !Int, nEdgesD :: !Int, offsetsD :: !(U.Vector Int), edgeDstD :: !(U.Vector Int), edgeRevIndexD :: !(U.Vector Int), edgeCapD :: !(UM.MVector s c)};data DinicBuffer s c = DinicBuffer{distsD :: !(UM.MVector s Int), queueD :: !(Buffer s Vertex), iterD :: !(UM.MVector s Int)};maxFlowD :: (U.Unbox c, Num c, Ord c, Bounded c) => Int -> Int -> Int -> U.Vector (Vertex, Vertex, c) -> c;maxFlowD !nVerts !src !sink !edges = runST $ do { !dinic <- buildDinic nVerts edges; runDinic src sink dinic};undefD :: Int;undefD = -1;buildDinic :: forall c m . (U.Unbox c, Num c, PrimMonad m) => Int -> U.Vector (Vertex, Vertex, c) -> m (Dinic (PrimState m) c);buildDinic !nVertsD !edges = do { let { !offsetsD = U.scanl' (+) (0 :: Int) $ U.create $ do { !degs <- UM.replicate nVertsD (0 :: Int); G.forM_ edges $ \ (!v1, !v2, !_) -> do { GM.modify degs (+ 1) v1; GM.modify degs (+ 1) v2}; return degs}}; (!edgeDstD, !edgeRevIndexD, !edgeCapD) <- do { !edgeDst <- UM.replicate nEdgesD undefD; !edgeRevIndex <- UM.replicate nEdgesD undefD; !edgeCap <- UM.replicate nEdgesD (0 :: c); !edgeCounter <- U.thaw offsetsD; G.forM_ edges $ \ (!v1, !v2, !cap) -> do { !i1 <- GM.read edgeCounter v1; !i2 <- GM.read edgeCounter v2; GM.modify edgeCounter (+ 1) v1; GM.modify edgeCounter (+ 1) v2; GM.write edgeRevIndex i1 i2; GM.write edgeRevIndex i2 i1; GM.write edgeDst i1 v2; GM.write edgeDst i2 v1; GM.write edgeCap i1 cap}; (, , edgeCap) <$> G.unsafeFreeze edgeDst <*> G.unsafeFreeze edgeRevIndex}; return Dinic{..}} where { !nEdgesD = G.length edges * 2};runDinic :: forall c m . (U.Unbox c, Num c, Ord c, Bounded c, PrimMonad m) => Vertex -> Vertex -> Dinic (PrimState m) c -> m c;runDinic !src !sink dinic@Dinic{..} = do { bufs@DinicBuffer{..} <- DinicBuffer <$> UM.unsafeNew nVertsD <*> newBufferAsQueue nVertsD <*> U.thaw offsetsD; flip fix 0 $ \ loopBfs !flow -> do { GM.set distsD undefD; clearBuffer queueD; runDinicBfs src sink dinic bufs; !distSink <- UM.read distsD sink; if distSink == undefD then return flow else do { U.unsafeCopy iterD offsetsD; flip fix flow $ \ loopDfs f -> do { !df <- runDinicDfs src sink maxBound dinic bufs; if df > 0 then loopDfs $! f + df else loopBfs f}}}};runDinicBfs :: forall c m . (U.Unbox c, Num c, Ord c, PrimMonad m) => Vertex -> Vertex -> Dinic (PrimState m) c -> DinicBuffer (PrimState m) c -> m ();runDinicBfs !src !sink Dinic{..} DinicBuffer{..} = do { UM.write distsD src 0; pushBack queueD src; fix $ \ loop -> popFront queueD >>= \case { Nothing -> return (); Just !v1 -> do { !notEnd <- (== undefD) <$> UM.read distsD sink; when notEnd $ do { let { !iStart = offsetsD U.! v1; !iEnd = offsetsD U.! (v1 + 1)}; !dist1 <- UM.read distsD v1; U.forM_ (U.generate (iEnd - iStart) (+ iStart)) $ \ i12 -> do { let { !v2 = edgeDstD U.! i12}; !cap12 <- UM.read edgeCapD i12; !notVisited <- (== undefD) <$> UM.read distsD v2; when (cap12 > 0 && notVisited) $ do { UM.write distsD v2 (dist1 + 1); pushBack queueD v2}}; loop}}}};runDinicDfs :: forall c m . (U.Unbox c, Num c, Ord c, PrimMonad m) => Vertex -> Vertex -> c -> Dinic (PrimState m) c -> DinicBuffer (PrimState m) c -> m c;runDinicDfs !v0 !sink !flow0 Dinic{..} DinicBuffer{..} = runDfs v0 flow0 where { runDfs !v1 !flow | v1 == sink = return flow | otherwise = fix $ \ visitNeighbor -> do { !i1 <- UM.read iterD v1; if i1 >= offsetsD U.! (v1 + 1) then do { return 0} else do { UM.write iterD v1 (i1 + 1); let { !v2 = edgeDstD U.! i1}; !cap12 <- UM.read edgeCapD i1; !connected <- (<) <$> UM.read distsD v1 <*> UM.read distsD v2; if cap12 > 0 && connected then do { !flow' <- runDfs v2 $! min flow cap12; if flow' > 0 then do { modifyFlow i1 flow'; return flow'} else visitNeighbor} else visitNeighbor}}; modifyFlow !i1 !flow = do { UM.modify edgeCapD (subtract flow) i1; UM.modify edgeCapD (+ flow) (edgeRevIndexD U.! i1)}};twoPointers :: Int -> (Int -> Int -> Bool) -> [(Int, Int)];twoPointers !n !p = unfoldr (uncurry f) s0 where { !s0 = (0, 0) :: (Int, Int); f l r | l == n = Nothing | not (p l r) = f (l + 1) (max (l + 1) r) | otherwise = Just ((l, r'), (l + 1, max (l + 1) r')) where { r' = until ((||) <$> (== n - 1) <*> not . p l . succ) succ r}};twoPointersU :: Int -> (Int -> Int -> Bool) -> U.Vector (Int, Int);twoPointersU !n !p = U.unfoldr (uncurry f) s0 where { !s0 = (0, 0) :: (Int, Int); f l r | l == n = Nothing | not (p l r) = f (l + 1) (max (l + 1) r) | otherwise = Just ((l, r'), (l + 1, max (l + 1) r')) where { r' = until ((||) <$> (== n - 1) <*> not . p l . succ) succ r}};imos2D :: ((Int, Int), (Int, Int)) -> UArray (Int, Int) Int -> UArray (Int, Int) Int;imos2D !bounds_ !seeds = runSTUArray $ do { !arr <- newArray bounds_ (0 :: Int); let { (!minY, !minX) = fst bounds_}; forM_ (range bounds_) $ \ (!y, !x) -> do { !v <- if x == minX then return 0 else readArray arr (y, x - 1); let { !diff = seeds ! (y, x)}; writeArray arr (y, x) $! v + diff}; forM_ (range bounds_) $ \ (!x, !y) -> do { !v <- if y == minY then return 0 else readArray arr (y - 1, x); !diff <- readArray arr (y, x); writeArray arr (y, x) $! v + diff}; return arr};imos2DRev :: ((Int, Int), (Int, Int)) -> UArray (Int, Int) Int -> UArray (Int, Int) Int;imos2DRev !bounds_ !seeds = runSTUArray $ do { !arr <- newArray bounds_ (0 :: Int); let { (!minY, !minX) = fst bounds_}; let { (!maxY, !maxX) = snd bounds_}; forM_ [maxX, maxX - 1 .. minX] $ \ x -> do { forM_ [maxY, maxY - 1 .. minY] $ \ y -> do { !v <- if x == maxX then return 0 else readArray arr (y, x + 1); let { !diff = seeds ! (y, x)}; writeArray arr (y, x) $! v + diff}}; forM_ [maxX, maxX - 1 .. minX] $ \ x -> do { forM_ [maxY, maxY - 1 .. minY] $ \ y -> do { !v <- if y == maxY then return 0 else readArray arr (y + 1, x); !diff <- readArray arr (y, x); writeArray arr (y, x) $! v + diff}}; return arr};rolls :: (RandomGen g, UniformRange a, U.Unbox a) => Int -> (a, a) -> g -> U.Vector a;rolls n rng = U.unfoldrExactN n (uniformR rng);rollsM :: (StatefulGen g m, UniformRange a, U.Unbox a) => Int -> (a, a) -> g -> m (U.Vector a);rollsM n rng = U.replicateM n . uniformRM rng;uniformRSt :: (RandomGen g, UniformRange a, MonadState g m) => (a, a) -> m a;uniformRSt !rng = state (uniformR rng);class ShowGrid a where { showGrid :: a -> String; showGridN :: Int -> a -> String};instance (G.Vector v a, Show a) => ShowGrid (IxVector (Int, Int) (v a)) where { showGrid = showGridN 0; showGridN !len !grid = unlines $ map f [y0 .. y1] where { ((!y0, !x0), (!y1, !x1)) = boundsIV grid; f !y = unwords $ map (showN . (grid @!) . (y,)) [x0 .. x1]; showN x = let { !s = show x; !lenX = length s} in replicate (len - lenX) ' ' ++ s}};($$) :: (Show a) => (a -> b) -> a -> b;($$) lhs rhs = lhs (dbgId rhs);infixr 0 $$;(.$) :: (Show b) => (b -> c) -> (a -> b) -> a -> c;g .$ f = \ a -> let { !b = dbgId (f a)} in g b;infixr 9 .$;dbgGrid :: (ShowGrid a) => a -> ();dbgGrid !gr = dbgS (showGrid gr);dbgGridId :: (ShowGrid a) => a -> a;dbgGridId !gr = let { !_ = dbgS (showGrid gr)} in gr;dbgGridN :: (ShowGrid a) => Int -> a -> ();dbgGridN !len !gr = dbgS (showGridN len gr);dbgGridNId :: (ShowGrid a) => Int -> a -> a;dbgGridNId !len !gr = let { !_ = dbgS (showGridN len gr)} in gr;dbgUF :: (PrimMonad m) => MUnionFind (PrimState m) -> m ();dbgUF (MUnionFind vec) = dbgUM vec;dbgUM :: (Show (v a), G.Vector v a, PrimMonad m) => (G.Mutable v) (PrimState m) a -> m ();dbgUM vec = do { !xs' <- G.unsafeFreeze vec; let { !_ = dbg xs'}; return ()};dbgSTree :: (Show (v a), G.Vector v a, PrimMonad m) => SegmentTree (G.Mutable v) (PrimState m) a -> m ();dbgSTree (SegmentTree _ mVec) = do { !vec <- G.unsafeFreeze mVec; let { !leaves = G.drop (G.length vec `div` 2 - 1) vec}; let { !_ = dbg leaves}; return ()};dbgSTreeAll :: (Show (v a), G.Vector v a, PrimMonad m) => SegmentTree (G.Mutable v) (PrimState m) a -> m ();dbgSTreeAll (SegmentTree _ mVec) = do { !vec <- G.unsafeFreeze mVec; flip fix (0 :: Int, 1 :: Int) $ \ loop (!n, !len) -> do { unless (G.length vec <= len) $ do { let { !vec' = G.take len . G.drop (len - 1) $ vec}; let { !_ = dbgS $ "> " ++ show vec'}; loop (n + 1, 2 * len)}}};;clamp :: (Ord a) => (a, a) -> a -> a;clamp (!low, !high) !a = min high (max a low);flipOrder :: Ordering -> Ordering;flipOrder = \case { GT -> LT; LT -> GT; EQ -> EQ};square :: (Num a) => a -> a;square !x = x * x;{-# INLINE modifyArray #-};modifyArray :: (MArray a e m, Ix i) => a i e -> (e -> e) -> i -> m ();modifyArray !ary !f !i = do { !v <- f <$> readArray ary i; writeArray ary i v};{-# INLINE (.:) #-};(.:) :: (b -> c) -> (a1 -> a2 -> b) -> (a1 -> a2 -> c);(.:) = (.) . (.);{-# INLINE (.:.) #-};(.:.) :: (b -> c) -> (a1 -> a2 -> a3 -> b) -> (a1 -> a2 -> a3 -> c);(.:.) = (.) . (.) . (.);{-# INLINE (.!) #-};(.!) :: (b -> c) -> (a -> b) -> a -> c;(.!) = (.) . ($!);foldFor :: (Foldable t) => b -> t a -> (b -> a -> b) -> b;foldFor !s0 !xs !f = foldl' f s0 xs;foldForG :: (G.Vector v a) => b -> v a -> (b -> a -> b) -> b;foldForG !s0 !xs !f = G.foldl' f s0 xs;foldForM :: (Foldable t, Monad m) => b -> t a -> (b -> a -> m b) -> m b;foldForM !s0 !xs !m = foldM m s0 xs;foldForMG :: (PrimMonad m, G.Vector v a) => b -> v a -> (b -> a -> m b) -> m b;foldForMG !s0 !xs !m = G.foldM' m s0 xs;swapDupeU :: U.Vector (Int, Int) -> U.Vector (Int, Int);swapDupeU = U.concatMap (\ vs -> U.fromListN 2 [vs, swap vs]);swapDupeW :: U.Vector (Int, Int, Int) -> U.Vector (Int, Int, Int);swapDupeW = U.concatMap (\ (!v1, !v2, !d) -> U.fromListN 2 [(v1, v2, d), (v2, v1, d)]);{-# INLINE slice #-};slice :: (G.Vector v a) => Int -> Int -> v a -> v a;slice !l !r !vec = G.slice l (max 0 (r - l + 1)) vec;{-# INLINE rangeG #-};rangeG :: (G.Vector v Int) => Int -> Int -> v Int;rangeG !i !j = G.enumFromN i (succ j - i);{-# INLINE rangeV #-};rangeV :: Int -> Int -> V.Vector Int;rangeV = rangeG;{-# INLINE rangeU #-};rangeU :: Int -> Int -> U.Vector Int;rangeU = rangeG;{-# INLINE rangeGR #-};rangeGR :: (G.Vector v Int) => Int -> Int -> v Int;rangeGR !i !j = G.enumFromStepN j (-1) (succ j - i);{-# INLINE rangeVR #-};rangeVR :: Int -> Int -> V.Vector Int;rangeVR = rangeGR;{-# INLINE rangeUR #-};rangeUR :: Int -> Int -> U.Vector Int;rangeUR = rangeGR;{-# INLINE repM_ #-};repM_ :: (Monad m) => Int -> Int -> (Int -> m ()) -> m ();repM_ !l !r !act = inner l where { inner !i | i > r = return () | otherwise = act i >> inner (succ i)};{-# INLINE repRM_ #-};repRM_ :: (Monad m) => Int -> Int -> (Int -> m ()) -> m ();repRM_ !l !r !act = inner r where { inner !i | i < l = return () | otherwise = act i >> inner (pred i)};constructN0 :: (U.Unbox a) => a -> Int -> (U.Vector a -> a) -> U.Vector a;constructN0 !x0 !n !f = U.constructN n $ \ vec -> if U.null vec then x0 else f vec;{-# INLINE times #-};times :: Int -> (a -> a) -> a -> a;times !n !f = inner 0 where { inner i !s | i >= n = s | otherwise = inner (i + 1) $! f s};interleave :: [a] -> [a] -> [a];interleave xs [] = xs; interleave [] ys = ys; interleave (x : xs) (y : ys) = x : y : interleave xs ys;combs :: Int -> [a] -> [[a]];combs _ [] = []; combs k as@(!(_ : xs)) | k == 0 = [[]] | k == 1 = map pure as | k == l = pure as | k > l = [] | otherwise = run (l - 1) (k - 1) as $ combs (k - 1) xs where { l = length as; run :: Int -> Int -> [a] -> [[a]] -> [[a]]; run n k ys cs | n == k = map (ys ++) cs | otherwise = map (q :) cs ++ run (n - 1) k qs (drop dc cs) where { (!(q : qs)) = take (n - k + 1) ys; dc = product [(n - k + 1) .. (n - 1)] `div` product [1 .. (k - 1)]}};swapDupe :: (a, a) -> [(a, a)];swapDupe (!x1, !x2) = [(x1, x2), (x2, x1)];add2 :: (Int, Int) -> (Int, Int) -> (Int, Int);add2 (!y, !x) = bimap (y +) (x +);sub2 :: (Int, Int) -> (Int, Int) -> (Int, Int);sub2 (!y, !x) = bimap (y -) (x -);mul2 :: Int -> (Int, Int) -> (Int, Int);mul2 !m = both (m *);add3 :: (Int, Int, Int) -> (Int, Int, Int) -> (Int, Int, Int);add3 (!z1, !y1, !x1) (!z2, !y2, !x2) = (z1 + z2, y1 + y2, x1 + x2);sub3 :: (Int, Int, Int) -> (Int, Int, Int) -> (Int, Int, Int);sub3 (!z1, !y1, !x1) (!z2, !y2, !x2) = (z1 - z2, y1 - y2, x1 - x2);mul3 :: (Int, Int, Int) -> (Int, Int, Int) -> (Int, Int, Int);mul3 (!z1, !y1, !x1) (!z2, !y2, !x2) = (z1 - z2, y1 - y2, x1 - x2);toRadian :: Double -> Double;toRadian degree = degree / 180.0 * pi;toDegree :: Double -> Double;toDegree rad = rad / pi * 180.0;fst4 :: (a, b, c, d) -> a;fst4 (!a, !_, !_, !_) = a;snd4 :: (a, b, c, d) -> b;snd4 (!_, !b, !_, !_) = b;thd4 :: (a, b, c, d) -> c;thd4 (!_, !_, !c, !_) = c;fth4 :: (a, b, c, d) -> d;fth4 (!_, !_, !_, !d) = d;traceMat2D :: (IArray a e, Ix i, Show e) => a (i, i) e -> ();traceMat2D !mat = traceSubMat2D mat (bounds mat);traceSubMat2D :: (IArray a e, Ix i, Show e) => a (i, i) e -> ((i, i), (i, i)) -> ();traceSubMat2D !mat ((!y0, !x0), (!yEnd, !xEnd)) = let { !_ = foldl' step () (range ys)} in () where { !xs = (y0, yEnd); !ys = (x0, xEnd); step !_ !y = traceShow (map (\ !x -> mat ! (y, x)) (range xs)) ()};isqrt :: Int -> Int;isqrt = round @Double . sqrt . fromIntegral;newtype BinaryLifting v m = BinaryLifting (v m) deriving (Show, Eq);newBinLift :: (G.Vector v s, Semigroup s) => s -> BinaryLifting v s;newBinLift !op0 = BinaryLifting ops where { !ops = G.iterateN (pred 63) (\ !op -> op <> op) op0};newBinLiftV :: (Semigroup s) => s -> BinaryLifting V.Vector s;newBinLiftV = newBinLift;newBinLiftU :: (Semigroup s, U.Unbox s) => s -> BinaryLifting U.Vector s;newBinLiftU = newBinLift;stimesBL :: (HasCallStack, Semigroup s, G.Vector v s) => BinaryLifting v s -> s -> Int -> s;stimesBL (BinaryLifting !ops) !s0 !n = U.foldl' step s0 (U.enumFromN 0 62) where { step !m !i | testBit n i = m <> ops G.! i | otherwise = m};mtimesBL :: (HasCallStack, Monoid m, G.Vector v m) => BinaryLifting v m -> Int -> m;mtimesBL !bin !n = stimesBL bin mempty n;sactBL :: (HasCallStack, SemigroupAction s a, G.Vector v s) => BinaryLifting v s -> a -> Int -> a;sactBL (BinaryLifting !ops) !acc0 !nAct = U.foldl' step acc0 (rangeG 0 62) where { step !acc !nBit | testBit nAct nBit = (ops G.! nBit) `sact` acc | otherwise = acc};mactBL :: (HasCallStack, MonoidAction m a, G.Vector v m) => BinaryLifting v m -> a -> Int -> a;mactBL = sactBL;newDoubling :: (G.Vector v a, G.Vector v Int) => a -> (a -> a) -> v a;newDoubling !oper0 !squareCompositeF = G.scanl' step oper0 $! G.enumFromN (1 :: Int) 62 where { step !oper !_ = squareCompositeF oper};newDoublingV :: a -> (a -> a) -> V.Vector a;newDoublingV = newDoubling;applyDoubling :: (HasCallStack, G.Vector v op) => v op -> a -> (a -> op -> a) -> Int -> a;applyDoubling !opers !x0 !act !n = foldl' step x0 [0 .. 62] where { !_ = dbgAssert $ G.length opers == 63; step !acc !nBit = if testBit n nBit then acc `act` (opers G.! nBit) else acc};{-# INLINE bsearch #-};bsearch :: (G.Vector v a) => v a -> (a -> Bool) -> (Maybe Int, Maybe Int);bsearch !vec !p = bisect 0 (G.length vec - 1) (p . (vec G.!));{-# INLINE bsearchL #-};bsearchL :: (G.Vector v a) => v a -> (a -> Bool) -> Maybe Int;bsearchL !vec !p = bisectL 0 (G.length vec - 1) (p . (vec G.!));{-# INLINE bsearchR #-};bsearchR :: (G.Vector v a) => v a -> (a -> Bool) -> Maybe Int;bsearchR !vec !p = bisectR 0 (G.length vec - 1) (p . (vec G.!));{-# INLINE bsearchExact #-};bsearchExact :: (G.Vector v a, Ord b) => v a -> (a -> b) -> b -> Maybe Int;bsearchExact !vec f !xref = case bisectL 0 (G.length vec - 1) ((<= xref) . f . (vec G.!)) of { Just !x | f (vec G.! x) == xref -> Just x; _ -> Nothing};{-# INLINE bisect #-};bisect :: Int -> Int -> (Int -> Bool) -> (Maybe Int, Maybe Int);bisect !l !r = runIdentity . bisectM l r . (return .);{-# INLINE bisectL #-};bisectL :: Int -> Int -> (Int -> Bool) -> Maybe Int;bisectL !a !b !c = fst $! bisect a b c;{-# INLINE bisectR #-};bisectR :: Int -> Int -> (Int -> Bool) -> Maybe Int;bisectR !a !b !c = snd $! bisect a b c;{-# INLINE bisectM #-};bisectM :: forall m . (Monad m) => Int -> Int -> (Int -> m Bool) -> m (Maybe Int, Maybe Int);bisectM !low !high !isOk = both wrap <$> inner (low - 1) (high + 1) where { inner :: Int -> Int -> m (Int, Int); inner !ok !ng | abs (ok - ng) == 1 = return (ok, ng); inner !ok !ng = isOk m >>= \case { True -> inner m ng; False -> inner ok m} where { !m = (ok + ng) `div` 2}; wrap :: Int -> Maybe Int; wrap !x | inRange (low, high) x = Just x | otherwise = Nothing};{-# INLINE bisectML #-};bisectML :: forall m . (Monad m) => Int -> Int -> (Int -> m Bool) -> m (Maybe Int);bisectML !a !b !c = fst <$> bisectM a b c;{-# INLINE bisectRM #-};bisectRM :: forall m . (Monad m) => Int -> Int -> (Int -> m Bool) -> m (Maybe Int);bisectRM !a !b !c = snd <$> bisectM a b c;{-# INLINE bisectF32 #-};bisectF32 :: Float -> Float -> Float -> (Float -> Bool) -> (Maybe Float, Maybe Float);bisectF32 !low !high !diff !isOk = both wrap (inner (low - diff) (high + diff)) where { inner :: Float -> Float -> (Float, Float); inner !ok !ng | abs (ok - ng) <= diff = (ok, ng); inner !ok !ng | isOk m = inner m ng | otherwise = inner ok m where { !m = (ok + ng) / 2}; wrap :: Float -> Maybe Float; wrap !x | x == (low - diff) || x == (high + diff) = Nothing | otherwise = Just x};{-# INLINE bisectF32L #-};bisectF32L :: Float -> Float -> Float -> (Float -> Bool) -> Maybe Float;bisectF32L !a !b !c !d = fst $! bisectF32 a b c d;{-# INLINE bisectF32R #-};bisectF32R :: Float -> Float -> Float -> (Float -> Bool) -> Maybe Float;bisectF32R !a !b !c !d = snd $! bisectF32 a b c d;{-# INLINE bisectF64 #-};bisectF64 :: Double -> Double -> Double -> (Double -> Bool) -> (Maybe Double, Maybe Double);bisectF64 !low !high !diff !isOk = both wrap (inner (low - diff) (high + diff)) where { inner :: Double -> Double -> (Double, Double); inner !ok !ng | abs (ok - ng) < diff = (ok, ng); inner !ok !ng | isOk m = inner m ng | otherwise = inner ok m where { !m = (ok + ng) / 2}; wrap :: Double -> Maybe Double; wrap !x | x == (low - diff) || x == (high + diff) = Nothing | otherwise = Just x};{-# INLINE bisectF64L #-};bisectF64L :: Double -> Double -> Double -> (Double -> Bool) -> Maybe Double;bisectF64L !a !b !c !d = fst $! bisectF64 a b c d;{-# INLINE bisectF64R #-};bisectF64R :: Double -> Double -> Double -> (Double -> Bool) -> Maybe Double;bisectF64R !a !b !c !d = snd $! bisectF64 a b c d;isqrtSlow :: Int -> Int;isqrtSlow n = fromJust $ bisectR 0 n ((< n) . (^ (2 :: Int)));newtype ToParent = ToParent (U.Vector Vertex);instance Semigroup ToParent where { (ToParent !vec1) <> (ToParent !vec2) = ToParent $ U.map f vec2 where { !_ = dbgAssert (G.length vec1 == G.length vec2); f (-1) = -1; f i = vec1 U.! i}};instance SemigroupAction ToParent Vertex where { sact (ToParent !vec) !i = vec U.! i};type LcaCache = (ToParent, U.Vector Int, BinaryLifting V.Vector ToParent);treeDepthInfo :: Int -> (Int -> [Int]) -> Int -> (ToParent, U.Vector Int);treeDepthInfo !nVerts !graph !root = runST $ do { !parents <- UM.replicate nVerts (-1 :: Int); !depths <- UM.replicate nVerts (-1 :: Int); flip fix (0 :: Int, -1 :: Int, [root]) $ \ loop (!depth, !parent, !vs) -> do { forM_ vs $ \ v -> do { UM.unsafeWrite depths v depth; UM.unsafeWrite parents v parent; let { !vs' = filter (/= parent) $ graph v}; loop (succ depth, v, vs')}}; (,) <$> (ToParent <$> U.unsafeFreeze parents) <*> U.unsafeFreeze depths};lcaCache :: Int -> (Vertex -> [Vertex]) -> Vertex -> LcaCache;lcaCache !nVerts !graph !root = (toParent, depths, toParentN) where { (!toParent, !depths) = treeDepthInfo nVerts graph root; !toParentN = newBinLift toParent};lca :: (HasCallStack) => LcaCache -> Int -> Int -> (Int, Int);lca (!_, !depths, !toParentN) !v1 !v2 = (vLCA, depths U.! vLCA) where { !d1 = depths U.! v1; !d2 = depths U.! v2; parentN = sactBL toParentN; !v1' = if d1 <= d2 then v1 else v2; !v2' = parentN (if d1 > d2 then v1 else v2) (abs $ d1 - d2); !dLCA = fromJust . snd $ bisect 0 (min d1 d2) $ \ d -> parentN v1' d /= parentN v2' d; !vLCA = parentN v1' dLCA};lcaLen :: (HasCallStack) => LcaCache -> Int -> Int -> Int;lcaLen cache@(!_, !depths, !_) !v1 !v2 = let { (!_, !d) = lca cache v1 v2; !d1 = depths U.! v1; !d2 = depths U.! v2} in (d1 - d) + (d2 - d);newtype ToParentM m = ToParentM (Int, U.Vector m);type FoldLcaCache m = (LcaCache, V.Vector (U.Vector m));foldLcaCache :: forall m . (Monoid m, U.Unbox m) => Int -> (Vertex -> [Vertex]) -> Vertex -> (Vertex -> Vertex -> m) -> FoldLcaCache m;foldLcaCache !nVerts !graph !root !edgeValueOf = (cache, foldCache) where { !cache@(!parents, !_, BinaryLifting !parents') = lcaCache nVerts graph root; foldCache :: V.Vector (U.Vector m); !foldCache = V.map snd $! newDoubling toParent appendArray where { !toParent = (0, U.map f (rangeG 0 (pred nVerts))) where { f v = case parents `sact` v of { (-1) -> mempty; p -> edgeValueOf v p}}; appendArray (!iBit, !ops) = (succ iBit, U.imap f ops) where { f !v0 !op = case (parents' V.! iBit) `sact` v0 of { (-1) -> op; p -> op <> (ops U.! p)}}}};foldLcaCache2 :: forall a m . (HasCallStack, Monoid m, U.Unbox m) => Array Int [(Vertex, a)] -> (a -> m) -> FoldLcaCache m;foldLcaCache2 !tree !toMonoid = foldLcaCache nVerts adj root getValue where { !root = 0 :: Vertex; !nVerts = rangeSize $ bounds tree; adj = map fst . (tree !); getValue !v !p = toMonoid . snd . fromJust . find ((== p) . fst) $ tree ! v};foldViaLca :: forall m . (HasCallStack, Monoid m, U.Unbox m) => FoldLcaCache m -> Int -> Int -> m;foldViaLca (cache@(!_, !depths, BinaryLifting !parents'), !ops') !v1 !v2 = let { (!_, !d) = lca cache v1 v2; !d1 = depths U.! v1; !d2 = depths U.! v2; !a1 = foldParentN v1 (d1 - d); !a2 = foldParentN v2 (d2 - d)} in a1 <> a2 where { foldParentN :: Vertex -> Int -> m; foldParentN !v0 !nthParent = snd $ V.ifoldl' step (v0, mempty) input where { !input = V.zip parents' ops'; step :: (Vertex, m) -> Int -> (ToParent, U.Vector m) -> (Vertex, m); step (!v, !acc) !iBit (!parents, !ops) | testBit nthParent iBit = (parents `sact` v, acc <> (ops U.! v)) | otherwise = (v, acc)}};type Edge = (Vertex, Vertex);type WEdgeWith w = (Vertex, Vertex, w);type EdgeId = Int;data SparseGraph i w = SparseGraph{boundsSG :: !(i, i), nVertsSG :: !Int, nEdgesSG :: !Int, offsetsSG :: !(U.Vector Int), adjacentsSG :: !(U.Vector Vertex), edgeWeightsSG :: !(U.Vector w)} deriving (Show);{-# INLINE buildSG #-};buildSG :: (Unindex i) => (i, i) -> U.Vector (i, i) -> SparseGraph i ();buildSG !boundsSG !edges = buildRawSG boundsSG $ U.map (\ (!i1, !i2) -> (ix i1, ix i2, ())) edges where { ix = index boundsSG};{-# INLINE buildWSG #-};buildWSG :: (Unindex i, UM.Unbox w) => (i, i) -> U.Vector (i, i, w) -> SparseGraph i w;buildWSG !boundsSG !edges = buildRawSG boundsSG $ U.map (\ (!i1, !i2, !w) -> (ix i1, ix i2, w)) edges where { ix = index boundsSG};{-# INLINE buildRawSG #-};buildRawSG :: (Unindex i, UM.Unbox w) => (i, i) -> U.Vector (Vertex, Vertex, w) -> SparseGraph i w;buildRawSG !boundsSG !edges = let { !nEdgesSG = U.length edges; !nVertsSG = rangeSize boundsSG; !offsetsSG = U.scanl' (+) 0 $ U.create $ do { !outDegs <- UM.replicate nVertsSG (0 :: Int); U.forM_ edges $ \ (!v1, !_, !_) -> do { UM.modify outDegs (+ 1) v1}; return outDegs}; !_ = dbgAssert (U.last offsetsSG == nEdgesSG); (!adjacentsSG, !edgeWeightsSG) = runST $ do { !mOffsets <- U.thaw offsetsSG; !mAdjacents <- UM.unsafeNew nEdgesSG; !mWeights <- UM.unsafeNew nEdgesSG; U.forM_ edges $ \ (!v1, !v2, !w) -> do { !iEdgeFlatten <- UM.unsafeRead mOffsets v1; UM.unsafeWrite mOffsets v1 (iEdgeFlatten + 1); UM.unsafeWrite mAdjacents iEdgeFlatten v2; UM.unsafeWrite mWeights iEdgeFlatten w}; (,) <$> U.unsafeFreeze mAdjacents <*> U.unsafeFreeze mWeights}} in SparseGraph{..};{-# INLINE adj #-};adj :: SparseGraph i w -> Vertex -> U.Vector Vertex;adj SparseGraph{..} v = U.unsafeSlice o1 (o2 - o1) adjacentsSG where { !o1 = U.unsafeIndex offsetsSG v; !o2 = U.unsafeIndex offsetsSG (v + 1)};{-# INLINE eAdj #-};eAdj :: SparseGraph i w -> Vertex -> U.Vector (EdgeId, Vertex);eAdj SparseGraph{..} v = U.imap ((,) . (+ o1)) vs where { !o1 = U.unsafeIndex offsetsSG v; !o2 = U.unsafeIndex offsetsSG (v + 1); !vs = U.unsafeSlice o1 (o2 - o1) adjacentsSG};{-# INLINE adjIx #-};adjIx :: (Unindex i) => SparseGraph i w -> i -> U.Vector i;adjIx gr i = U.map (unindex (boundsSG gr)) $ adj gr v where { !v = index (boundsSG gr) i};{-# INLINE adjW #-};adjW :: (U.Unbox w) => SparseGraph i w -> Vertex -> U.Vector (Vertex, w);adjW SparseGraph{..} v = U.zip vs ws where { !o1 = U.unsafeIndex offsetsSG v; !o2 = U.unsafeIndex offsetsSG (v + 1); !vs = U.unsafeSlice o1 (o2 - o1) adjacentsSG; !ws = U.unsafeSlice o1 (o2 - o1) edgeWeightsSG};{-# INLINE adjWIx #-};adjWIx :: (Unindex i, U.Unbox w) => SparseGraph i w -> i -> U.Vector (i, w);adjWIx gr i = U.map (first (unindex (boundsSG gr))) $ adjW gr v where { !v = index (boundsSG gr) i};dfsSG :: (Unindex i) => SparseGraph i w -> i -> IxVector i (U.Vector Int);dfsSG gr@SparseGraph{..} !sourceIx = IxVector boundsSG $ U.create $ do { let { !undef = -1 :: Int}; !dist <- UM.replicate nVertsSG undef; flip fix (0 :: Int, index boundsSG sourceIx) $ \ loop (!depth, !v1) -> do { UM.write dist v1 depth; U.forM_ (gr `adj` v1) $ \ v2 -> do { !d <- UM.read dist v2; when (d == undef) $ do { loop (succ depth, v2)}}}; return dist};dfsEveryPathSG :: SparseGraph Int Int -> Int -> Int;dfsEveryPathSG gr@SparseGraph{..} !source = runST $ do { !vis <- UM.replicate nVertsSG False; flip fix (0 :: Int, source) $ \ loop (!d1, !v1) -> do { UM.write vis v1 True; !v2s <- U.filterM (fmap not . UM.read vis . fst) $ gr `adjW` v1; !maxDistance <- fmap (U.foldl' max (0 :: Int)) . U.forM v2s $ \ (!v2, !w) -> do { loop (d1 + w, v2)}; UM.write vis v1 False; return $ max d1 maxDistance}};componentsVecSG :: (Ix i) => SparseGraph i w -> i -> IxVector i (U.Vector Bool);componentsVecSG gr@SparseGraph{..} !sourceIx = IxVector boundsSG $ U.create $ do { !vis <- UM.replicate nVertsSG False; flip fix source $ \ loop v1 -> do { UM.write vis v1 True; let { !v2s = gr `adj` v1}; U.forM_ v2s $ \ v2 -> do { !visited <- UM.read vis v2; unless visited $ do { loop v2}}}; return vis} where { !source = index boundsSG sourceIx :: Vertex};bfsSG :: (Ix i) => SparseGraph i w -> i -> IxVector i (U.Vector Int);bfsSG gr@SparseGraph{..} !sourceIx = IxVector boundsSG $ genericBfs (gr `adj`) nVertsSG (index boundsSG sourceIx);genericBfs :: (Int -> U.Vector Int) -> Int -> Vertex -> U.Vector Int;genericBfs !gr !nVerts !source = U.create $ do { let { !undef = -1 :: Int}; !dist <- UM.replicate nVerts undef; !queue <- newBufferAsQueue nVerts; pushBack queue source; UM.unsafeWrite dist source (0 :: Int); fix $ \ loop -> do { popFront queue >>= \case { Nothing -> return (); Just !v1 -> do { !d1 <- UM.unsafeRead dist v1; U.forM_ (gr v1) $ \ v2 -> do { !lastD <- UM.unsafeRead dist v2; when (lastD == undef) $ do { UM.unsafeWrite dist v2 (d1 + 1); pushBack queue v2}}; loop}}}; return dist};genericBfs01 :: (Ix i, U.Unbox i) => (i, i) -> (i -> U.Vector (i, Int)) -> U.Vector i -> IxUVector i Int;genericBfs01 !bndExt !gr !sources = IxVector bndExt $ U.create $ do { let { !undef = -1 :: Int}; let { !nVertsExt = rangeSize bndExt}; !vec <- IxVector bndExt <$> UM.replicate nVertsExt undef; !deque <- newBufferAsDeque nVertsExt; U.forM_ sources $ \ vExt -> do { pushFront deque (0 :: Int, vExt); writeIV vec vExt (0 :: Int)}; let { step !w0 !vExt0 = do { !wReserved0 <- readIV vec vExt0; when (w0 == wReserved0) $ do { U.forM_ (gr vExt0) $ \ (!vExt, !dw) -> do { let { !w = w0 + dw}; !wReserved <- readIV vec vExt; when (wReserved == undef || w < wReserved) $ do { writeIV vec vExt w; if dw == 0 then pushFront deque (w, vExt) else pushBack deque (w, vExt)}}}}}; fix $ \ loop -> popFront deque >>= \case { Nothing -> return (); Just (!w, !vExt) -> do { step w vExt; loop}}; return $ vecIV vec};djSG :: forall i w . (Ix i, U.Unbox i, Num w, Ord w, U.Unbox w) => SparseGraph i w -> w -> U.Vector i -> IxUVector i w;djSG gr@SparseGraph{..} !undef !is0 = IxVector boundsSG $ genericDj (gr `adjW`) nVertsSG undef (U.map (index boundsSG) is0);genericDj :: forall w . (U.Unbox w, Num w, Ord w) => (Int -> U.Vector (Int, w)) -> Int -> w -> U.Vector Int -> U.Vector w;genericDj !gr !nVerts !undef !vs0 = U.create $ do { !dist <- UM.replicate nVerts undef; let { !heap0 = H.fromList $ map (H.Entry 0) (U.toList vs0) :: H.Heap (H.Entry w Int)}; U.forM_ vs0 $ \ v -> do { UM.write dist v 0}; flip fix heap0 $ \ loop heap -> case H.uncons heap of { Nothing -> return (); Just (H.Entry !w1 !v1, heap') -> do { (w1 >) <$> UM.read dist v1 >>= \case { True -> loop heap'; False -> do { loop <=< (\ f -> U.foldM' f heap' (gr v1)) $ \ h (!v2, !dw2) -> do { !w2 <- UM.read dist v2; let { !w2' = merge w1 dw2}; if w2 == undef || w2' < w2 then do { UM.write dist v2 w2'; return $ H.insert (H.Entry w2' v2) h} else return h}}}}}; return dist} where { merge :: w -> w -> w; merge = (+)};dfsPathSG :: (Unindex i) => SparseGraph i w -> i -> i -> Maybe [Vertex];dfsPathSG gr@SparseGraph{..} !sourceIx !sinkIx = runST $ do { let { !undef = -1 :: Int}; !dist <- UM.replicate nVertsSG undef; let { loop !depth !v1 !stack = do { !lastD1 <- UM.read dist v1; if lastD1 /= undef then return Nothing else do { UM.write dist v1 depth; if v1 == sink then return $ Just (v1 : stack) else do { flip fix (gr `adj` v1) $ \ visitNeighbors v2s -> case G.uncons v2s of { Nothing -> return Nothing; Just (!v2, !v2s') -> do { (<|>) <$> loop (succ depth) v2 (v1 : stack) <*> visitNeighbors v2s'}}}}}}; loop (0 :: Int) source []} where { !source = index boundsSG sourceIx; !sink = index boundsSG sinkIx};treeDfsPathSG :: (HasCallStack, Unindex i) => SparseGraph i w -> i -> i -> [Vertex];treeDfsPathSG gr@SparseGraph{..} !sourceIx !sinkIx = fromJust $ runST $ do { let { !undef = -1 :: Int}; let { loop !parent !v1 !stack = do { if v1 == sink then return $ Just (v1 : stack) else do { flip fix (U.filter (/= parent) $ gr `adj` v1) $ \ visitNeighbors v2s -> case G.uncons v2s of { Nothing -> return Nothing; Just (!v2, !v2s') -> do { (<|>) <$> loop v1 v2 (v1 : stack) <*> visitNeighbors v2s'}}}}}; loop undef source []} where { !source = index boundsSG sourceIx; !sink = index boundsSG sinkIx};createDfsTreeSG :: (Unindex i) => SparseGraph i w -> i -> U.Vector Vertex;createDfsTreeSG gr@SparseGraph{..} !sourceIx = U.create $ do { let { !undef = -1 :: Int}; !prev <- UM.replicate nVertsSG undef; !queue <- newBufferAsQueue nVertsSG; pushBack queue source; fix $ \ loop -> do { popFront queue >>= \case { Nothing -> return (); Just !v1 -> do { U.forM_ (gr `adj` v1) $ \ v2 -> do { !p <- UM.unsafeRead prev v2; when (p == undef) $ do { UM.unsafeWrite prev v2 v1; pushBack queue v2}}; loop}}}; return prev} where { !source = index boundsSG sourceIx};createBfsTreeSG :: (Unindex i) => SparseGraph i w -> i -> U.Vector Vertex;createBfsTreeSG gr@SparseGraph{..} !sourceIx = U.create $ do { let { !undef = -1 :: Int}; !prev <- UM.replicate nVertsSG undef; !queue <- newBufferAsQueue nVertsSG; pushBack queue source; fix $ \ loop -> do { popFront queue >>= \case { Nothing -> return (); Just !v1 -> do { U.forM_ (gr `adj` v1) $ \ v2 -> do { !p <- UM.unsafeRead prev v2; when (p == undef) $ do { UM.unsafeWrite prev v2 v1; pushBack queue v2}}; loop}}}; return prev} where { !source = index boundsSG sourceIx};createDjTreeSG :: forall w . (U.Unbox w, Num w, Ord w) => (Int -> U.Vector (Int, w)) -> Int -> w -> U.Vector Int -> U.Vector (Vertex, w);createDjTreeSG !gr !nVerts !undef !vs0 = U.create $ do { !dist <- UM.replicate nVerts (-1, undef); let { !heap0 = H.fromList $ map (H.Entry 0) (U.toList vs0) :: H.Heap (H.Entry w Int)}; U.forM_ vs0 $ \ v -> do { UM.write dist v (-1, 0)}; flip fix heap0 $ \ loop heap -> case H.uncons heap of { Nothing -> return (); Just (H.Entry !w1 !v1, heap') -> do { ((w1 >) . snd) <$> UM.read dist v1 >>= \case { True -> loop heap'; False -> do { loop <=< (\ f -> U.foldM' f heap' (gr v1)) $ \ h (!v2, !dw2) -> do { (!_, !w2) <- UM.read dist v2; let { !w2' = merge w1 dw2}; if w2 == undef || w2' < w2 then do { UM.write dist v2 (v1, w2'); return $ H.insert (H.Entry w2' v2) h} else return h}}}}}; return dist} where { merge :: w -> w -> w; merge = (+)};restoreParentTreePath :: U.Vector Vertex -> Vertex -> [Vertex];restoreParentTreePath !ps !sink = inner [sink] sink where { inner path v | p == (-1) = path | otherwise = inner (p : path) p where { p = ps U.! v}};topSortSG :: SparseGraph i w -> [Vertex];topSortSG gr@SparseGraph{..} = runST $ do { !vis <- UM.replicate nVertsSG False; let { dfsM !acc !v = do { UM.unsafeRead vis v >>= \case { True -> return acc; False -> do { UM.unsafeWrite vis v True; !vs <- U.filterM (fmap not . UM.unsafeRead vis) $ gr `adj` v; (v :) <$> U.foldM' dfsM acc vs}}}}; U.foldM' dfsM [] (rangeU 0 (pred nVertsSG))};topScc1SG :: forall i w m . (PrimMonad m) => SparseGraph i w -> UM.MVector (PrimState m) Bool -> Vertex -> m [Vertex];topScc1SG !gr' !vis !v0 = do { flip fix ([], v0) $ \ loop (!acc, !v) -> do { UM.unsafeRead vis v >>= \case { True -> return acc; False -> do { UM.unsafeWrite vis v True; !vs <- U.filterM (fmap not . UM.unsafeRead vis) $ gr' `adj` v; (v :) <$> U.foldM' (curry loop) acc vs}}}};revSG :: (Unindex i, U.Unbox w) => SparseGraph i w -> SparseGraph i w;revSG SparseGraph{..} = buildRawSG boundsSG edges' where { !vws = U.zip adjacentsSG edgeWeightsSG; !edges' = flip U.concatMap (rangeU 0 (pred nVertsSG)) $ \ v1 -> let { !o1 = U.unsafeIndex offsetsSG v1; !o2 = U.unsafeIndex offsetsSG (v1 + 1); !vw2s = U.unsafeSlice o1 (o2 - o1) vws} in U.map (\ (v2, !w2) -> (v2, v1, w2)) vw2s};topSccSG :: (Unindex i, U.Unbox w) => SparseGraph i w -> [[Int]];topSccSG gr = collectSccPreorderSG $ topSortSG gr where { !gr' = revSG gr; collectSccPreorderSG :: [Int] -> [[Int]]; collectSccPreorderSG !topVerts = runST $ do { !vis <- UM.replicate (nVertsSG gr) False; filter (not . null) <$> mapM (topScc1SG gr' vis) topVerts}};treeDepthInfoSG :: SparseGraph Int w -> Int -> (ToParent, U.Vector Int);treeDepthInfoSG gr@SparseGraph{..} !root = runST $ do { !parents <- UM.replicate nVerts (-1 :: Int); !depths <- UM.replicate nVerts (-1 :: Int); flip fix (0 :: Int, -1 :: Int, U.singleton root) $ \ loop (!depth, !parent, !vs) -> do { U.forM_ vs $ \ v -> do { UM.unsafeWrite depths v depth; UM.unsafeWrite parents v parent; let { !vs' = U.filter (/= parent) $ gr `adj` v}; loop (succ depth, v, vs')}}; (,) <$> (ToParent <$> U.unsafeFreeze parents) <*> U.unsafeFreeze depths} where { !nVerts = rangeSize boundsSG};lcaCacheSG :: SparseGraph Int w -> Vertex -> LcaCache;lcaCacheSG !gr !root = (toParent, depths, toParentN) where { (!toParent, !depths) = treeDepthInfoSG gr root; !toParentN = newBinLift toParent};foldTreeImpl :: forall m op a w . (Monad m) => SparseGraph Int w -> Vertex -> (op -> a -> a) -> (Vertex -> a) -> (a -> op) -> (Vertex -> a -> m ()) -> m a;foldTreeImpl !tree !root !sact_ !acc0At !toOp !memo = inner (-1) root where { inner :: Vertex -> Vertex -> m a; inner !parent !v1 = do { let { !acc0 = acc0At v1}; !res <- U.foldM' (\ acc v2 -> (`sact_` acc) . toOp <$> inner v1 v2) acc0 v2s; memo v1 res; return res} where { !v2s = U.filter (/= parent) $ tree `adj` v1}};foldTree :: SparseGraph Int w -> Vertex -> (op -> a -> a) -> (Vertex -> a) -> (a -> op) -> a;foldTree !tree !root !sact_ !acc0At !toOp = runIdentity $ foldTreeImpl tree root sact_ acc0At toOp (\ _ _ -> return ());scanTree :: (G.Vector v a) => SparseGraph Int w -> Vertex -> (op -> a -> a) -> (Vertex -> a) -> (a -> op) -> v a;scanTree !tree !root !sact_ !acc0At !toOp = G.create $ do { dp <- GM.unsafeNew nVerts; !_ <- foldTreeImpl tree root sact_ acc0At toOp $ \ v a -> do { GM.unsafeWrite dp v a}; return dp} where { !nVerts = rangeSize $! boundsSG tree};scanTreeU :: (U.Unbox a) => SparseGraph Int w -> Vertex -> (op -> a -> a) -> (Vertex -> a) -> (a -> op) -> U.Vector a;scanTreeU = scanTree;scanTreeV :: SparseGraph Int w -> Vertex -> (op -> a -> a) -> (Vertex -> a) -> (a -> op) -> V.Vector a;scanTreeV = scanTree;foldTreeAllSG :: forall a op w . (U.Unbox a, U.Unbox op, MonoidAction op a) => SparseGraph Int w -> (Vertex -> a) -> (a -> op) -> U.Vector a;foldTreeAllSG !tree !acc0At !toOp = let { !treeDp = scanTreeU tree root0 mact acc0At toOp; !rootDp = U.create $ do { !dp <- UM.unsafeNew nVerts; flip fix (-1, op0, root0) $ \ runRootDp (!parent, !parentOp, !v1) -> do { let { !children = U.filter (/= parent) $ tree `adj` v1}; let { !opL = U.scanl' (\ op v2 -> (op <>) . toOp $ treeDp U.! v2) op0 children}; let { !opR = U.scanr' (\ v2 op -> (<> op) . toOp $ treeDp U.! v2) op0 children}; let { !x1 = (parentOp <> U.last opL) `mact` acc0At v1}; UM.write dp v1 x1; flip U.imapM_ children $ \ !i2 !v2 -> do { let { !lrOp = (opL U.! i2) <> (opR U.! succ i2)}; let { !v1Acc = (parentOp <> lrOp) `mact` acc0At v2}; runRootDp (v1, toOp v1Acc, v2)}}; return dp}} in rootDp where { !nVerts = rangeSize $ boundsSG tree; !root0 = 0 :: Int; !op0 = mempty @op};bfs01_grid4_typical043 :: (HasCallStack) => IxUVector (Int, Int) Bool -> (Int, Int) -> IxUVector (Int, Int, Int) Int;bfs01_grid4_typical043 !isBlock !source = IxVector boundsExt $ U.create $ do { !vec <- IxVector boundsExt <$> UM.replicate (4 * nVerts) undef; let { !redundantSpace = 0}; !deque <- newBufferAsDeque (redundantSpace + 4 * nVerts); forM_ [0 .. 3] $ \ iDir -> do { let { !vExt = (iDir, fst source, snd source)}; pushFront deque (0 :: Int, vExt); writeIV vec vExt (0 :: Int)}; let { extract !w0 vExt0@(!iDir0, !y0, !x0) = do { !wReserved0 <- readIV vec vExt0; when (w0 == wReserved0) $ do { U.iforM_ dirs $ \ iDir (!dy, !dx) -> do { let { !v = (y0 + dy, x0 + dx)}; when (inRange bounds_ v && not (isBlock @! v)) $ do { let { !w = bool (w0 + 1) w0 (iDir == iDir0)}; let { !vExt = (iDir, y0 + dy, x0 + dx)}; !wReserved <- readIV vec vExt; when (wReserved == undef || w < wReserved) $ do { writeIV vec vExt w; if iDir == iDir0 then pushFront deque (w, vExt) else pushBack deque (w, vExt)}}}}}}; fix $ \ loop -> popFront deque >>= \case { Nothing -> return (); Just (!w, !v) -> do { extract w v; loop}}; return $ vecIV vec} where { !undef = -1 :: Int; (!height, !width) = both succ . snd $ boundsIV isBlock; !bounds_ = boundsIV isBlock; !boundsExt = ((0, 0, 0), (3, height - 1, width - 1)); !nVerts = rangeSize bounds_; !dirs = U.fromList [(0, 1), (0, -1), (1, 0), (-1, 0)]};bfsGrid317E_MBuffer :: (HasCallStack) => IxUVector (Int, Int) Bool -> (Int, Int) -> IxUVector (Int, Int) Int;bfsGrid317E_MBuffer !isBlock !source = IxVector bounds_ $ runST $ do { !vis <- IxVector bounds_ <$> UM.replicate (rangeSize bounds_) undef; !queue <- newBufferAsQueue (rangeSize bounds_); pushBack queue source; writeIV vis source 0; fix $ \ loop -> popFront queue >>= \case { Nothing -> return (); Just !yx1 -> do { !d <- readIV vis yx1; U.forM_ (nexts yx1) $ \ yx2 -> do { whenM ((== undef) <$> readIV vis yx2) $ do { writeIV vis yx2 (d + 1); pushBack queue yx2}}; loop}}; U.unsafeFreeze $ vecIV vis} where { !undef = -1 :: Int; !bounds_ = boundsIV isBlock; nexts !yx0 = U.filter ((&&) <$> inRange bounds_ <*> not . (isBlock @!)) $ U.map (add2 yx0) dyxs; !dyxs = U.fromList [(1, 0), (-1, 0), (0, 1), (0, -1)]};abc335e :: U.Vector Int -> SparseGraph Int () -> U.Vector Int;abc335e !xs gr@SparseGraph{..} = U.create $ do { let { !undef = 0 :: Int}; !dist <- UM.replicate nVertsSG undef; !done <- UM.replicate nVertsSG False; let { !heap0 = H.singleton $ H.Entry (xs U.! 0, Down 1) 0}; UM.write dist 0 (1 :: Int); flip fix heap0 $ \ loop heap -> case H.uncons heap of { Nothing -> return (); Just (H.Entry (!_, Down !w1) !v1, !heap') -> do { UM.read done v1 >>= \case { True -> loop heap'; False -> do { UM.write done v1 True; loop <=< (\ f -> U.foldM' f heap' (gr `adj` v1)) $ \ h v2 -> do { let { !w2' = bool (w1 + 1) w1 (xs U.! v1 == xs U.! v2)}; !b2 <- UM.read done v2; !w2 <- UM.read dist v2; if not b2 && w2' > w2 then do { UM.write dist v2 w2'; return $ H.insert (H.Entry (xs U.! v2, Down w2') v2) h} else return h}}}}}; return dist};distsNN :: (U.Unbox w, Num w, Ord w) => Int -> w -> U.Vector (Int, Int, w) -> IxUVector (Int, Int) w;distsNN !nVerts !undef !wEdges = IxVector bnd $ U.create $ do { !vec <- UM.replicate (nVerts * nVerts) undef; U.forM_ wEdges $ \ (!v1, !v2, !w) -> do { UM.write vec (index bnd (v1, v2)) w}; forM_ [0 .. nVerts - 1] $ \ k -> do { forM_ [0 .. nVerts - 1] $ \ i -> do { forM_ [0 .. nVerts - 1] $ \ j -> do { !x1 <- UM.read vec (index bnd (i, j)); !x2 <- do { !tmp1 <- UM.read vec (index bnd (i, k)); !tmp2 <- UM.read vec (index bnd (k, j)); return $! bool (tmp1 + tmp2) undef $ tmp1 == undef || tmp2 == undef}; UM.write vec (index bnd (i, j)) $! min x1 x2}}}; return vec} where { bnd :: ((Int, Int), (Int, Int)); bnd = ((0, 0), (nVerts - 1, nVerts - 1))};compressU :: (HasCallStack) => U.Vector Int -> (U.Vector Int, U.Vector Int);compressU xs = (indexer, U.map (fromJust . fst . f) xs) where { !indexer = U.uniq $ U.modify VAI.sort xs; f !x = bisect 0 (pred (U.length indexer)) $ \ i -> indexer U.! i <= x};invNumG :: (HasCallStack) => Int -> (G.Vector v Int) => v Int -> Int;invNumG xMax xs = runST $ do { !stree <- newSTreeU (+) (xMax + 1) (0 :: Int); foldForMG (0 :: Int) xs $ \ acc x -> do { !s <- if x == xMax then return 0 else fromJust <$> querySTree stree (succ x) xMax; modifySTree stree succ x; return $! acc + s}};compressInvNumG :: (HasCallStack) => U.Vector Int -> Int;compressInvNumG xs = invNumG (pred (U.length xs')) xs' where { !xs' = snd $ compressU xs};{-# INLINE sortMo #-};sortMo :: Int -> U.Vector (Int, Int) -> U.Vector Int;sortMo !maxL !lrs = U.modify (VAI.sortBy compareF) (G.generate (G.length lrs) id) where { !q = G.length lrs; !blockLength = max 1 . ceiling @Double $ (fromIntegral maxL / sqrt (fromIntegral q)); compareF !i1 !i2 = let { (!l1, !r1) = lrs U.! i1; (!l2, !r2) = lrs U.! i2; !b1 = l1 `div` blockLength; !b2 = l2 `div` blockLength; !res = compare b1 b2 <> bool (compare r2 r1) (compare r1 r2) (even b1)} in res};runMoG :: (PrimMonad m, U.Unbox x, G.Vector v b) => U.Vector x -> U.Vector (Int, Int) -> (a -> x -> m a) -> (a -> x -> m a) -> (a -> x -> m a) -> (a -> x -> m a) -> (a -> b) -> a -> m (v b);runMoG !xs !lrs !onInsL !onInsR !onRemL !onRemR !extract !state0 = do { !result <- GM.unsafeNew q; U.foldM'_ (step result) ((0 :: Int, -1 :: Int), state0) (sortMo maxL lrs); G.unsafeFreeze result} where { !q = G.length lrs; !maxL = U.maximum (U.map fst lrs); step result ((!l0, !r0), !s0) iLrs = do { let { (!l, !r) = lrs U.! iLrs}; !s' <- do { !s1 <- U.foldM' onInsL s0 (slice l (l0 - 1) xs); !s2 <- U.foldM' onInsR s1 (slice (r0 + 1) r xs); !s3 <- U.foldM' onRemL s2 (slice l0 (l - 1) xs); !s4 <- U.foldM' onRemR s3 (slice (r + 1) r0 xs); return s4}; GM.unsafeWrite result iLrs $! extract s'; return ((l, r), s')}};runMoPureG :: (U.Unbox x, G.Vector v b) => U.Vector x -> U.Vector (Int, Int) -> (a -> x -> a) -> (a -> x -> a) -> (a -> x -> a) -> (a -> x -> a) -> (a -> b) -> a -> v b;runMoPureG !xs !lrs !onInsL !onInsR !onRemL !onRemR !extract !state0 = runST $ do { runMoG xs lrs (return .: onInsL) (return .: onInsR) (return .: onRemL) (return .: onRemR) extract state0};runMo :: (PrimMonad m, U.Unbox x, U.Unbox b) => U.Vector x -> U.Vector (Int, Int) -> (a -> x -> m a) -> (a -> x -> m a) -> (a -> x -> m a) -> (a -> x -> m a) -> (a -> b) -> a -> m (U.Vector b);runMo = runMoG;runMoPure :: (U.Unbox x, U.Unbox b) => U.Vector x -> U.Vector (Int, Int) -> (a -> x -> a) -> (a -> x -> a) -> (a -> x -> a) -> (a -> x -> a) -> (a -> b) -> a -> U.Vector b;runMoPure = runMoPureG;simpleRunMo :: (PrimMonad m, U.Unbox x, U.Unbox a) => U.Vector x -> U.Vector (Int, Int) -> (a -> x -> m a) -> (a -> x -> m a) -> a -> m (U.Vector a);simpleRunMo !xs !lrs !onIns !onRem !state0 = runMo xs lrs onIns onIns onRem onRem id state0;simpleRunMoPure :: (U.Unbox x, U.Unbox a) => U.Vector x -> U.Vector (Int, Int) -> (a -> x -> a) -> (a -> x -> a) -> a -> U.Vector a;simpleRunMoPure !xs !lrs !onIns !onRem !state0 = runMoPure xs lrs onIns onIns onRem onRem id state0;int :: IO Int;int = readLn;ints :: IO [Int];ints = unfoldr (BS.readInt . BS.dropWhile isSpace) <$> BS.getLine;class ReadBS a where { {-# INLINE convertBS #-}; convertBS :: BS.ByteString -> a; default convertBS :: (Read a) => BS.ByteString -> a; convertBS = read . BS.unpack; {-# INLINE readBS #-}; readBS :: BS.ByteString -> (a, BS.ByteString); readBS !bs = let { (!bs1, !bs2) = BS.break isSpace bs} in (convertBS bs1, bs2); {-# INLINE readMayBS #-}; readMayBS :: BS.ByteString -> Maybe (a, BS.ByteString); readMayBS !bs | BS.null bs = Nothing | otherwise = let { (!bs1, !bs2) = BS.break isSpace bs} in Just (convertBS bs1, bs2)};instance ReadBS Int where { {-# INLINE convertBS #-}; convertBS = fst . readBS; {-# INLINE readBS #-}; readBS = fromJust . readMayBS; {-# INLINE readMayBS #-}; readMayBS = BS.readInt};instance ReadBS Integer where { {-# INLINE convertBS #-}; convertBS = fst . readBS; {-# INLINE readBS #-}; readBS = fromJust . readMayBS; {-# INLINE readMayBS #-}; readMayBS = BS.readInteger};instance ReadBS Float;instance ReadBS Double;instance ReadBS Char where { {-# INLINE convertBS #-}; convertBS = BS.head};instance ReadBS String where { {-# INLINE convertBS #-}; convertBS = BS.unpack};instance ReadBS BS.ByteString where { {-# INLINE convertBS #-}; convertBS = id};instance (ReadBS a, U.Unbox a) => ReadBS (U.Vector a) where { {-# INLINE convertBS #-}; convertBS = convertG; readBS = (, BS.empty) . convertG; readMayBS !bs | BS.null bs = Nothing | otherwise = Just (readBS bs)};instance (ReadBS a) => ReadBS (V.Vector a) where { {-# INLINE convertBS #-}; convertBS = convertG; readBS = (, BS.empty) . convertG; readMayBS !bs | BS.null bs = Nothing | otherwise = Just (readBS bs)};instance (ReadBS a1, ReadBS a2) => ReadBS (a1, a2) where { {-# INLINE convertBS #-}; convertBS !bs0 = let { (!a1, !bs1) = readBS (BS.dropWhile isSpace bs0); !a2 = convertBS (BS.dropWhile isSpace bs1)} in (a1, a2); {-# INLINE readBS #-}; readBS = fromJust . readMayBS; {-# INLINE readMayBS #-}; readMayBS !bs0 = do { (!x1, !bs1) <- readMayBS bs0; (!x2, !bs2) <- readMayBS bs1; Just ((x1, x2), bs2)}};instance (ReadBS a1, ReadBS a2, ReadBS a3) => ReadBS (a1, a2, a3) where { {-# INLINE convertBS #-}; convertBS !bs0 = let { (!a1, !bs1) = readBS (BS.dropWhile isSpace bs0); (!a2, !bs2) = readBS (BS.dropWhile isSpace bs1); !a3 = convertBS (BS.dropWhile isSpace bs2)} in (a1, a2, a3); {-# INLINE readBS #-}; readBS = fromJust . readMayBS; {-# INLINE readMayBS #-}; readMayBS !bs0 = do { (!x1, !bs1) <- readMayBS bs0; (!x2, !bs2) <- readMayBS bs1; (!x3, !bs3) <- readMayBS bs2; Just ((x1, x2, x3), bs3)}};instance (ReadBS a1, ReadBS a2, ReadBS a3, ReadBS a4) => ReadBS (a1, a2, a3, a4) where { {-# INLINE convertBS #-}; convertBS !bs0 = let { (!a1, !bs1) = readBS (BS.dropWhile isSpace bs0); (!a2, !bs2) = readBS (BS.dropWhile isSpace bs1); (!a3, !bs3) = readBS (BS.dropWhile isSpace bs2); !a4 = convertBS (BS.dropWhile isSpace bs3)} in (a1, a2, a3, a4); {-# INLINE readBS #-}; readBS = fromJust . readMayBS; {-# INLINE readMayBS #-}; readMayBS !bs0 = do { (!x1, !bs1) <- readMayBS bs0; (!x2, !bs2) <- readMayBS bs1; (!x3, !bs3) <- readMayBS bs2; (!x4, !bs4) <- readMayBS bs3; Just ((x1, x2, x3, x4), bs4)}};instance (ReadBS a1, ReadBS a2, ReadBS a3, ReadBS a4, ReadBS a5) => ReadBS (a1, a2, a3, a4, a5) where { {-# INLINE convertBS #-}; convertBS !bs0 = let { (!a1, !bs1) = readBS (BS.dropWhile isSpace bs0); (!a2, !bs2) = readBS (BS.dropWhile isSpace bs1); (!a3, !bs3) = readBS (BS.dropWhile isSpace bs2); (!a4, !bs4) = readBS (BS.dropWhile isSpace bs3); !a5 = convertBS (BS.dropWhile isSpace bs4)} in (a1, a2, a3, a4, a5); {-# INLINE readBS #-}; readBS = fromJust . readMayBS; {-# INLINE readMayBS #-}; readMayBS !bs0 = do { (!x1, !bs1) <- readMayBS bs0; (!x2, !bs2) <- readMayBS bs1; (!x3, !bs3) <- readMayBS bs2; (!x4, !bs4) <- readMayBS bs3; (!x5, !bs5) <- readMayBS bs4; Just ((x1, x2, x3, x4, x5), bs5)}};instance (ReadBS a1, ReadBS a2, ReadBS a3, ReadBS a4, ReadBS a5, ReadBS a6) => ReadBS (a1, a2, a3, a4, a5, a6) where { {-# INLINE convertBS #-}; convertBS !bs0 = let { (!a1, !bs1) = readBS (BS.dropWhile isSpace bs0); (!a2, !bs2) = readBS (BS.dropWhile isSpace bs1); (!a3, !bs3) = readBS (BS.dropWhile isSpace bs2); (!a4, !bs4) = readBS (BS.dropWhile isSpace bs3); (!a5, !bs5) = readBS (BS.dropWhile isSpace bs4); !a6 = convertBS (BS.dropWhile isSpace bs5)} in (a1, a2, a3, a4, a5, a6); {-# INLINE readBS #-}; readBS = fromJust . readMayBS; {-# INLINE readMayBS #-}; readMayBS !bs0 = do { (!x1, !bs1) <- readMayBS bs0; (!x2, !bs2) <- readMayBS bs1; (!x3, !bs3) <- readMayBS bs2; (!x4, !bs4) <- readMayBS bs3; (!x5, !bs5) <- readMayBS bs4; (!x6, !bs6) <- readMayBS bs5; Just ((x1, x2, x3, x4, x5, x6), bs6)}};convertG :: (ReadBS a, G.Vector v a) => BS.ByteString -> v a;convertG = G.unfoldr (readMayBS . BS.dropWhile isSpace);convertNG :: (ReadBS a, G.Vector v a) => Int -> BS.ByteString -> v a;convertNG !n = G.unfoldrExactN n (readBS . BS.dropWhile isSpace);auto :: (ReadBS a) => IO a;auto = convertBS <$> BS.getLine;ints1 :: IO Int;ints1 = auto;ints2 :: IO (Int, Int);ints2 = auto;ints3 :: IO (Int, Int, Int);ints3 = auto;ints4 :: IO (Int, Int, Int, Int);ints4 = auto;ints5 :: IO (Int, Int, Int, Int, Int);ints5 = auto;ints6 :: IO (Int, Int, Int, Int, Int, Int);ints6 = auto;intsW :: (G.Vector v Int) => Int -> IO (v Int);intsW !w = G.unfoldrExactN w (fromJust . BS.readInt . BS.dropWhile isSpace) <$> BS.getLine;intsG :: (G.Vector v Int) => IO (v Int);intsG = G.unfoldr (BS.readInt . BS.dropWhile isSpace) <$> BS.getLine;intsV :: IO (V.Vector Int);intsV = intsG;intsU :: IO (U.Vector Int);intsU = intsG;digitsU :: IO (U.Vector Int);digitsU = U.unfoldr (fmap (first digitToInt) . BS.uncons) <$> BS.getLine;convertNBS :: forall a . (U.Unbox a, ReadBS a) => Int -> V.Vector BS.ByteString -> U.Vector a;convertNBS !n !bss = U.unfoldrExactN n step $ fromJust (V.uncons bss) where { step :: (BS.ByteString, V.Vector BS.ByteString) -> (a, (BS.ByteString, V.Vector BS.ByteString)); step (!cur, !rest) | BS.null cur' = step $ fromJust (V.uncons rest) | otherwise = let { (!x, !cur'') = readBS cur'} in (x, (cur'', rest)) where { !cur' = BS.dropWhile isSpace cur}};getHW :: (U.Unbox a, ReadBS a) => Int -> Int -> IO (U.Vector a);getHW !h !w = convertNBS (h * w) <$> V.replicateM h BS.getLine;getMat :: Int -> Int -> IO (IxVector (Int, Int) (U.Vector Int));getMat !h !w = IxVector ((0, 0), (h - 1, w - 1)) <$> getHW h w;convertCharsHW :: V.Vector BS.ByteString -> U.Vector Char;convertCharsHW !bss = U.create $ do { !vec <- UM.unsafeNew (h * w); V.iforM_ bss $ \ y bs -> repM_ 0 (w - 1) $ \ x -> do { let { !char = BS.index bs x}; UM.unsafeWrite vec (w * y + x) char}; return vec} where { !w = BS.length (V.head bss); !h = V.length bss};getGrid :: Int -> Int -> IO (IxUVector (Int, Int) Char);getGrid !h !w = IxVector ((0, 0), (h - 1, w - 1)) . convertCharsHW <$> V.replicateM h BS.getLine;{-# INLINE endlBSB #-};endlBSB :: BSB.Builder;endlBSB = BSB.char7 '\n';putBSB :: BSB.Builder -> IO ();putBSB = BSB.hPutBuilder stdout;putLnBSB :: BSB.Builder -> IO ();putLnBSB = BSB.hPutBuilder stdout . (<> endlBSB);class ShowBSB a where { showBSB :: a -> BSB.Builder; default showBSB :: (Show a) => a -> BSB.Builder; showBSB = BSB.string8 . show};instance ShowBSB Int where { showBSB = BSB.intDec};instance ShowBSB Integer where { showBSB = BSB.integerDec};instance ShowBSB Float where { showBSB = BSB.floatDec};instance ShowBSB Double where { showBSB = BSB.doubleDec};showLnBSB :: (ShowBSB a) => a -> BSB.Builder;showLnBSB = (<> endlBSB) . showBSB;printBSB :: (ShowBSB a) => a -> IO ();printBSB = putBSB . showBSB;concatBSB :: (G.Vector v a) => (a -> BSB.Builder) -> v a -> BSB.Builder;concatBSB f = G.foldr' ((<>) . f) mempty;unwordsBSB :: (ShowBSB a, G.Vector v a) => v a -> BSB.Builder;unwordsBSB = concatBSB ((<> BSB.string7 " ") . showBSB);unlinesBSB :: (ShowBSB a, G.Vector v a) => v a -> BSB.Builder;unlinesBSB = concatBSB showLnBSB;yn :: Bool -> String;yn = bool "No" "Yes";ynBSB :: Bool -> BSB.Builder;ynBSB = bool (BSB.string8 "No") (BSB.string8 "Yes");printYn :: Bool -> IO ();printYn = putLnBSB . ynBSB;constructFor :: (U.Unbox a, U.Unbox b) => a -> U.Vector b -> (U.Vector a -> b -> a) -> U.Vector a;constructFor !x0 !input !f = U.create $ do { !vec <- UM.unsafeNew (U.length input + 1); UM.unsafeWrite vec 0 x0; flip U.imapM_ input $ \ lenS1 x -> do { !vec' <- U.take (succ lenS1) <$> U.unsafeFreeze vec; UM.unsafeWrite vec (succ lenS1) $! f vec' x}; return vec};relaxMany :: (HasCallStack, G.Vector v a, G.Vector v (Int, a), G.Vector v b) => (a -> a -> a) -> v a -> v b -> (b -> v (Int, a)) -> v a;relaxMany !relax !vec0 !input !expander = G.create $ do { !vec <- G.unsafeThaw vec0; G.forM_ input $ \ x -> do { G.forM_ (expander x) $ \ (!i, !x') -> do { GM.modify vec (`relax` x') i}}; return vec};irelaxMany :: (HasCallStack, G.Vector v a, G.Vector v (Int, a), G.Vector v b) => (a -> a -> a) -> v a -> v b -> (Int -> b -> v (Int, a)) -> v a;irelaxMany !relax !vec0 !input !expander = G.create $ do { !vec <- G.unsafeThaw vec0; G.iforM_ input $ \ ix x -> do { G.forM_ (expander ix x) $ \ (!i, !x') -> do { GM.modify vec (`relax` x') i}}; return vec};relaxMany' :: (Monoid m, U.Unbox m, U.Unbox a) => U.Vector m -> U.Vector a -> (a -> U.Vector (Int, m)) -> U.Vector m;relaxMany' !vec0 !input !expander = U.create $ do { !vec <- U.unsafeThaw vec0; U.forM_ input $ \ x -> do { U.forM_ (expander x) $ \ (!i, !x') -> do { UM.modify vec (<> x') i}}; return vec};{-# INLINE pushBasedConstructN #-};pushBasedConstructN :: (HasCallStack, G.Vector v a, G.Vector v (Int, a)) => (a -> a -> a) -> v a -> (Int -> v a -> v (Int, a)) -> v a;pushBasedConstructN !relax !vec0 !expander = G.create $ do { !vec <- G.unsafeThaw vec0; repM_ 0 (GM.length vec - 1) $ \ iFrom -> do { !freezed <- G.unsafeFreeze (GM.take (iFrom + 1) vec); G.forM_ (expander iFrom freezed) $ \ (!iTo, !x') -> do { GM.modify vec (`relax` x') iTo}}; return vec};spansU :: Int -> Int -> U.Vector ((Int, Int), (Int, Int));spansU !l !r = U.map (\ len -> ((l, l + len - 1), (l + len, r))) $ rangeU 1 (r - l);iwiSpansU :: Int -> Int -> U.Vector ((Int, Int), (Int, Int));iwiSpansU !l !r = U.map (\ len -> ((l, l + len - 1), (l + len + 1, r))) $ rangeU 0 (r - l);iwiSpansU' :: Int -> Int -> U.Vector ((Int, Int), Int, (Int, Int));iwiSpansU' !l !r = U.map (\ len -> ((l, l + len - 1), l + len, (l + len + 1, r))) $ rangeU 0 (r - l);spanDP :: (U.Unbox a) => Int -> a -> (Int -> a) -> (IxVector (Int, Int) (U.Vector a) -> (Int, Int) -> a) -> IxVector (Int, Int) (U.Vector a);spanDP !n !undef !onOne !f = constructIV ((0, 0), (n + 1, n)) $ \ vec (!spanLen, !spanL) -> if spanLen == 0 || spanL >= (n + 1 - spanLen) then undef else if spanLen == 1 then onOne spanL else f vec (spanLen, spanL);unBitSet :: Int -> Int -> U.Vector Int;unBitSet n bits = U.filter (testBit bits) (U.generate n id);tspDP :: Int -> IxUVector (Int, Int) Int -> U.Vector Int;tspDP !nVerts !gr = U.constructN (nSets * nVerts) $ \ vec -> case G.length vec `divMod` nVerts of { (!s, !vTo) | s == bit vTo -> 0 :: Int; (!s, !vTo) | not (testBit s vTo) -> undef; (!s, !vTo) -> let { !s' = clearBit s vTo; !candidates = (U.take nVerts . U.drop (nVerts * s')) vec} in U.maximum $ flip U.imap candidates $ \ vFrom w0 -> let { !dw = gr @! (vFrom, vTo)} in bool (w0 + dw) undef (dw == undef || w0 == undef)} where { !nSets = bit nVerts; !undef = -1 :: Int};enumerateBitSets :: Int -> [[Int]];enumerateBitSets !n = inner [[]] [] (bit n - 1) where { inner :: [[Int]] -> [Int] -> Int -> [[Int]]; inner !results !acc 0 = acc : results; inner !results !acc !rest = U.foldl' step results (powersetU rest') where { !lsb = countTrailingZeros rest; !rest' = clearBit rest lsb; step !res !set = let { !set' = set .|. bit lsb} in inner res (set' : acc) (rest' .&. complement set')}};lisOf :: (HasCallStack) => U.Vector Int -> Int;lisOf !xs = runST $ do { !stree <- newSTreeU max (G.length xs) (0 :: Int); U.forM_ xs $ \ x -> do { !n0 <- fromMaybe 0 <$> querySTree stree 0 (x - 1); insertSTree stree x (n0 + 1)}; fromJust <$> querySTree stree 0 (G.length xs - 1)};lcsOf :: BS.ByteString -> BS.ByteString -> Int;lcsOf !s !t = U.last . vecIV . constructIV bnd $ \ sofar i -> case i of { (0, 0) -> 0 :: Int; (0, _) -> 0 :: Int; (_, 0) -> 0 :: Int; (!ls, !lt) -> n1 `max` n2 `max` n3 where { n1 = sofar @! (ls - 1, lt); n2 = sofar @! (ls, lt - 1); n3 | BS.index s (ls - 1) == BS.index t (lt - 1) = sofar @! (ls - 1, lt - 1) + 1 | otherwise = 0}} where { bnd = ((0, 0), (BS.length s, BS.length t))};log2 :: (FiniteBits b) => b -> Int;log2 !x = finiteBitSize x - 1 - countLeadingZeros x;log2CeilInt :: Int -> Int;log2CeilInt !x = msb + ceiling_ where { !msb = log2 x; !ceiling_ = if clearBit x msb > 0 then 1 else 0};bitCeil :: Int -> Int;bitCeil = bit . log2CeilInt;exgcd :: (Integral a) => a -> a -> (a, a, a);exgcd a b = f $ go a b 1 0 0 1 where { go r0 r1 s0 s1 t0 t1 | r1 == 0 = (r0, s0, t0) | otherwise = go r1 r2 s1 s2 t1 t2 where { (!q, !r2) = r0 `divMod` r1; s2 = s0 - q * s1; t2 = t0 - q * t1}; f (!g, !u, !v) | g < 0 = (-g, -u, -v) | otherwise = (g, u, v)};invModGcd :: (Integral a) => a -> a -> Maybe a;invModGcd a m = case exgcd a m of { (1, na, _) -> Just na; _ -> Nothing};addMod, subMod, mulMod :: Int -> Int -> Int -> Int;addMod !x !a !modulo = (x + a) `mod` modulo;subMod !x !s !modulo = (x - s) `mod` modulo;mulMod !b !p !modulo = (b * p) `mod` modulo;factMod :: Int -> Int -> Int;factMod 0 _ = 1; factMod 1 _ = 1; factMod !n !m = n * factMod (n - 1) m `rem` m;powModConst :: Int -> Int -> Int -> Int;powModConst !base !power !modulo = powModByCache power (powModCache (base `mod` modulo) modulo);invModF :: Int -> Int -> Int;invModF !d !modulo = invModFC modulo (powModCache d modulo);divModF :: Int -> Int -> Int -> Int;divModF !x !d !modulo = divModFC x (powModCache d modulo) `rem` modulo;powModCache :: Int -> Int -> (Int, U.Vector Int);powModCache !base !modulo = (modulo, doubling) where { doubling = newDoubling base (\ x -> x * x `rem` modulo)};powModByCache :: Int -> (Int, U.Vector Int) -> Int;powModByCache !power (!modulo, !cache) = foldl' step 1 [0 .. 62] where { step !acc !nBit = if testBit power nBit then acc * (cache U.! nBit) `rem` modulo else acc};invModFC :: Int -> (Int, U.Vector Int) -> Int;invModFC !primeModulo = powModByCache (primeModulo - 2);divModFC :: Int -> (Int, U.Vector Int) -> Int;divModFC !x context@(!modulo, !_) = x * invModFC modulo context `rem` modulo;factMods :: Int -> Int -> U.Vector Int;factMods !n !modulo = U.scanl' (\ !x !y -> x * y `rem` modulo) (1 :: Int) $ U.fromList [(1 :: Int) .. n];bcMod :: Int -> Int -> Int -> Int;bcMod !n !r !modulo = foldl' (\ !x !y -> divModF x y modulo) (facts U.! n) [facts U.! r, facts U.! (n - r)] where { facts = factMods n modulo};prevPermutationVec :: (Ord e, G.Vector v e, G.Vector v (Down e)) => v e -> v e;prevPermutationVec = G.map (\case { Down !x -> x}) . G.modify (void . GM.nextPermutation) . G.map Down;dictOrderModuloVec :: (HasCallStack, G.Vector v Int) => v Int -> Int -> Int;dictOrderModuloVec xs modulo = runST $ do { !stree <- newSTreeU (+) (G.length xs + 1) (0 :: Int); let { !facts = factMods (G.length xs) modulo}; !counts <- flip G.imapM xs $ \ i x -> do { !nUsed <- fromJust <$> querySTree stree 0 x; let { !nUnused = x - nUsed}; let { !factMod = facts G.! (G.length xs - (i + 1))}; let { !inc = nUnused * factMod `rem` modulo}; insertSTree stree x 1; return inc}; return $! succ $! G.foldl1' (\ !acc x -> (acc + x) `rem` modulo) counts};class TypeInt a where { typeInt :: Proxy a -> Int};newtype ModInt p = ModInt{getModInt :: Int} deriving (Eq, P.Prim)                                            deriving newtype (Ord, Read, Show, Real);instance (TypeInt p) => Num (ModInt p) where { (ModInt !x1) + (ModInt !x2) = ModInt $! (x1 + x2) `mod` typeInt (Proxy @p); (ModInt !x1) * (ModInt !x2) = ModInt $! (x1 * x2) `mod` typeInt (Proxy @p); negate (ModInt !v) = ModInt $ (-v) `mod` typeInt (Proxy @p); abs = id; signum _ = 1; fromInteger = ModInt . fromInteger};instance (TypeInt p) => Fractional (ModInt p) where { recip (ModInt !x) = ModInt $! invModF x (typeInt (Proxy @p)); fromRational !r = ModInt n / ModInt d where { n = fromInteger $! Ratio.numerator r; d = fromInteger $! Ratio.denominator r}};instance (TypeInt p) => Enum (ModInt p) where { toEnum = ModInt . (`mod` typeInt (Proxy @p)); fromEnum = coerce};instance (TypeInt p) => SemigroupAction (Product (ModInt p)) (ModInt p) where { sact (Product !x1) !x2 = x1 * x2};newtype instance  U.MVector s (ModInt p) = MV_ModInt (P.MVector s (ModInt p));newtype instance  U.Vector (ModInt p) = V_ModInt (P.Vector (ModInt p));deriving via (U.UnboxViaPrim (ModInt p)) instance GM.MVector UM.MVector (ModInt p);deriving via (U.UnboxViaPrim (ModInt p)) instance G.Vector U.Vector (ModInt p);instance U.Unbox (ModInt p);data RollingHash b p = RollingHash{sourceLength :: !Int, dimensions :: !(U.Vector Int), hashSum :: !(U.Vector Int)} deriving (Show, Eq);data HashInt = HashInt;instance TypeInt HashInt where { typeInt _ = 100};newRH :: forall p . (TypeInt p) => String -> RollingHash HashInt p;newRH !source = RollingHash n bn hashSum_ where { !p = typeInt (Proxy @p); !b = typeInt (Proxy @HashInt); !n = length source; !bn = U.iterateN (succ n) (\ lastB -> b * lastB `mod` p) (1 :: Int); !hashSum_ = evalState (U.mapM (\ !ch -> state $ \ !acc -> f ch acc) $ U.fromList source) (0 :: Int) where { f :: Char -> Int -> (Int, Int); f !ch !lastX = dupe $! (lastX * b + ord ch) `mod` p}};lengthRH :: RollingHash b p -> Int;lengthRH (RollingHash !len !_ !_) = len;data HashSlice p = HashSlice{hashValue :: {-# UNPACK #-} !Int, hashLength :: {-# UNPACK #-} !Int} deriving (Show, Eq);sliceRH :: forall b p . (TypeInt p) => RollingHash b p -> Int -> Int -> HashSlice p;sliceRH (RollingHash !_ !bn !s) !i0 !i1 | i0 > i1 = emptyHS | otherwise = let { !len = i1 - i0 + 1; !s1 = s U.! i1; !s0 = fromMaybe 0 $ s U.!? pred i0; !value = (s1 - (bn U.! len) * s0) `mod` p} in HashSlice value len where { !p = typeInt (Proxy @p)};consHS :: forall b p . (TypeInt p) => RollingHash b p -> HashSlice p -> HashSlice p -> HashSlice p;consHS (RollingHash !_ !bn !_) (HashSlice !v0 !l0) (HashSlice !v1 !l1) = HashSlice value len where { !p = typeInt (Proxy @p); !value = ((bn U.! l1) * v0 + v1) `mod` p; !len = l0 + l1};emptyHS :: HashSlice p;emptyHS = HashSlice 0 0;concatHS :: forall b p t . (TypeInt p, Foldable t) => RollingHash b p -> t (HashSlice p) -> HashSlice p;concatHS !rhash !slices = foldl' (consHS rhash) emptyHS slices;mulMatToCol :: (Num e, IArray UArray e) => UArray (Int, Int) e -> [e] -> [e];mulMatToCol !mat !col = let { !rows = chunksOf n (elems mat)} in map (sum . zipWith (*) col) rows where { !n = length col; !_ = dbgAssert $ (== n) . succ . fst . snd $ bounds mat};mulMatToColMod :: UArray (Int, Int) Int -> Int -> [Int] -> [Int];mulMatToColMod !mat !modulus !col = let { !rows = chunksOf n (elems mat)} in map (foldl1' ((`mod` modulus) .: (+)) . zipWith (*) col) rows where { !n = length col; !_ = dbgAssert $ (== n) . succ . fst . snd $ bounds mat};mulMat :: (Num e, IArray UArray e) => UArray (Int, Int) e -> UArray (Int, Int) e -> UArray (Int, Int) e;mulMat !a !b = listArray @UArray ((i0, k0), (ix, kx)) [sum [a ! (i, j) * b ! (j', k) | (j, j') <- zip (range (j0, jx)) (range (j'0, j'x))] | i <- range (i0, ix), k <- range (k0, kx)] where { ((!i0, !j0), (!ix, !jx)) = bounds a; ((!j'0, !k0), (!j'x, !kx)) = bounds b; !_ = dbgAssert (jx - j0 == j'x - j'0)};mulMatMod :: Int -> UArray (Int, Int) Int -> UArray (Int, Int) Int -> UArray (Int, Int) Int;mulMatMod m a b = listArray @UArray ((i0, k0), (ix, kx)) [sum [a ! (i, j) * b ! (j', k) `mod` m | (j, j') <- zip (range (j0, jx)) (range (j'0, j'x))] `mod` m | i <- range (i0, ix), k <- range (k0, kx)] where { ((!i0, !j0), (!ix, !jx)) = bounds a; ((!j'0, !k0), (!j'x, !kx)) = bounds b; !_ = dbgAssert (jx - j0 == j'x - j'0)};unitMat :: Int -> UArray (Int, Int) Int;unitMat !n = accumArray @UArray (+) (0 :: Int) ((0, 0), (pred n, pred n)) $ map ((, 1) . dupe) [0 .. pred n];newtype MulMatMod p = MulMatMod (UArray (Int, Int) Int) deriving (Eq, Show);instance forall p . (TypeInt p) => Semigroup (MulMatMod p) where { (MulMatMod !m1) <> (MulMatMod !m2) = MulMatMod $ mulMatMod (typeInt (Proxy @p)) m1 m2};instance (TypeInt p) => SemigroupAction (MulMatMod p) [Int] where { sact (MulMatMod !mat) !col = mulMatToColMod mat (typeInt (Proxy @p)) col};rot45 :: (Int, Int) -> (Int, Int);rot45 (!x, !y) = (x - y, x + y);mDigitsRev :: (Integral n) => n -> n -> Maybe [n];mDigitsRev !base !i = if base < 1 then Nothing else Just $ dr base i where { dr _ 0 = []; dr !b !x = case base of { 1 -> genericTake x $ repeat 1; _ -> let { (!rest, !lastDigit) = quotRem x b} in lastDigit : dr b rest}};mDigits :: (Integral n) => n -> n -> Maybe [n];mDigits !base !i = reverse <$> mDigitsRev base i;digitsRev :: (Integral n) => n -> n -> [n];digitsRev !base = fromJust . mDigitsRev base;digits :: (Integral n) => n -> n -> [n];digits _ 0 = [0]; digits !base !x = reverse $ digitsRev base x;unDigits :: (Integral n) => n -> [n] -> n;unDigits !base = foldl' (\ !a !b -> a * base + b) 0;convertBase :: (Integral a) => a -> a -> [a] -> [a];convertBase !from !to = digits to . unDigits from;toDigitsU :: Int -> Int -> U.Vector Int;toDigitsU !base !x0 | x0 < base = U.singleton x0 | otherwise = U.unfoldr expand x0 where { expand 0 = Nothing; expand x = Just $ swap (x `divMod` base)};toNDigitsU :: Int -> Int -> Int -> U.Vector Int;toNDigitsU !base !nDigits !x0 = U.unfoldrExactN nDigits expand x0 where { expand x = swap (x `divMod` base)};unDigitsU :: Int -> U.Vector Int -> Int;unDigitsU !base !xs = fst $ U.foldl' step (0 :: Int, 1 :: Int) xs where { step (!acc, !d) !i = (acc + d * i, base * d)};primes :: [Int];primes = 2 : 3 : minus [5, 7 ..] (unionAll [[p * p, p * p + 2 * p ..] | p <- tail primes]) where { minus (x : xs) (y : ys) = case compare x y of { LT -> x : minus xs (y : ys); EQ -> minus xs ys; GT -> minus (x : xs) ys}; minus xs _ = xs; union (x : xs) (y : ys) = case compare x y of { LT -> x : union xs (y : ys); EQ -> x : union xs ys; GT -> y : union (x : xs) ys}; union xs [] = xs; union [] ys = ys; unionAll :: (Ord a) => [[a]] -> [a]; unionAll ((x : xs) : t) = x : union xs (unionAll $ pairs t) where { pairs ((x : xs) : (ys : t)) = (x : union xs ys) : pairs t; pairs _ = error "unionAll _ pairs: unreachable"}; unionAll _ = error "unionAll: unreachable"};primeFactors :: Int -> [(Int, Int)];primeFactors !n_ = map (\ !xs -> (head xs, length xs)) . group $ inner n_ input where { input = 2 : 3 : [y | x <- [5, 11 ..], y <- [x, x + 2]]; inner n pps@(p : ps) | n == 1 = [] | n < p * p = [n] | r == 0 = p : inner q pps | otherwise = inner n ps where { (q, r) = divMod n p}; inner _ _ = error "unreachable"};divisorsOf :: Int -> [Int];divisorsOf n = sort $ inner 1 where { inner k | k * k > n = [] | k * k == n = [k] | r == 0 = k : d : inner (succ k) | otherwise = inner (succ k) where { (!d, !r) = n `divMod` k}}
{- ORMOLU_ENABLE -}
-- }}}

{-# INLINE genericDjPath #-}
genericDjPath ::
  forall w.
  (U.Unbox w, Num w, Ord w) =>
  (Vertex -> U.Vector (Vertex, w)) ->
  Int ->
  w ->
  U.Vector Vertex ->
  (U.Vector w, U.Vector Vertex)
genericDjPath !gr !nVerts !undef !vs0 = runST $ do
  !dist <- UM.replicate nVerts undef
  !last <- UM.replicate nVerts (-1 :: Vertex)

  -- when there's loop:
  -- !done <- UM.replicate nVertsSG False

  let !heap0 = H.fromList $ map (H.Entry 0) (U.toList vs0) :: H.Heap (H.Entry w Int)
  U.forM_ vs0 $ \v -> do
    UM.write dist v 0

  flip fix heap0 $ \loop heap -> case H.uncons heap of
    Nothing -> return ()
    Just (H.Entry !w1 !v1, heap') -> do
      (w1 >) <$> UM.read dist v1 >>= \case
        -- better path was already visited
        True -> loop heap'
        False -> do
          loop <=< (\f -> U.foldM' f heap' (gr v1)) $ \h (!v2, !dw2) -> do
            !w2 <- UM.read dist v2
            let !w2' = merge w1 dw2
            if w2 == undef || w2' < w2
              then do
                UM.write dist v2 w2'
                UM.write last v2 v1
                return $ H.insert (H.Entry w2' v2) h
              else return h

  (,) <$> U.unsafeFreeze dist <*> U.unsafeFreeze last
  where
    merge :: w -> w -> w
    merge = (+)

printList :: (Show a) => [a] -> IO ()
printList = putStrLn . unwords . map show

putList :: (Show a) => [a] -> IO ()
putList = putStr . unwords . map show

restorePath :: U.Vector Vertex -> Vertex -> U.Vector Vertex
restorePath !toParent !sink = U.reverse $ U.unfoldr f sink
  where
    f !v
      | v == -2 = Nothing
      | v' == -1 = Just (v, -2)
      | otherwise = Just (v, v')
      where
        v' = toParent U.! v

-- verification-helper: PROBLEM https://judge.yosupo.jp/problem/shortest_path
main :: IO ()
main = do
  (!nVerts, !nEdges, !src, !sink) <- ints4
  !edges <- U.replicateM nEdges ints3

  let !gr = buildWSG (0, nVerts - 1) edges
  let (!dists, !track) = genericDjPath (gr `adjW`) nVerts (-1 :: Int) (U.singleton src)

  if track U.! sink == -1
    then print (-1 :: Int)
    else do
      let !path = restorePath track sink
      printList [dists U.! sink, G.length path - 1]
      U.zipWithM_ (\a b -> printList [a, b]) path (U.tail path)
